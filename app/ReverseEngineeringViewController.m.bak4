//
//  ReverseEngineeringViewController.m
//  iSH
//
//  Mini Hopper - Full Reverse Engineering Workspace
//

#import "ReverseEngineeringViewController.h"
#import "Terminal.h"
#import "ObjCAnalyzer.h"
#import "ARM64InstructionDecoder.h"
#import "FunctionAnalyzer.h"
#import "PseudoCodeGenerator.h"
#import "XREFManager.h"
#import "SyntaxHighlighter.h"
#import <mach-o/loader.h>
#import <mach-o/nlist.h>
#import <mach-o/fat.h>

// Mach-O structures analyzer
// Bridge to access iSH filesystem via Terminal commands

@interface MachOAnalyzer : NSObject
@property (nonatomic, strong) NSData *binaryData;
@property (nonatomic, strong) NSMutableArray *segments;
@property (nonatomic, strong) NSMutableArray *sections;
@property (nonatomic, strong) NSMutableArray *symbols;
@property (nonatomic, strong) NSMutableDictionary *imports;
@property (nonatomic, strong) NSMutableDictionary *exports;
- (instancetype)initWithData:(NSData *)data;
- (void)analyze;
@end

// Disassembler engine with real ARM64 decoder
@interface DisassemblerEngine : NSObject
@property (nonatomic, strong) ARM64InstructionDecoder *decoder;
@property (nonatomic, assign) uint64_t startAddress;
@property (nonatomic, strong) NSData *codeData;
- (NSArray *)disassembleAtAddress:(uint64_t)address length:(size_t)length;
- (NSString *)disassembleInstruction:(const uint8_t *)bytes address:(uint64_t)addr;
@end

// Control Flow Graph generator
@interface CFGGenerator : NSObject
@property (nonatomic, strong) DisassemblerEngine *engine;
- (NSDictionary *)generateCFGForFunction:(uint64_t)address;
- (NSArray *)findBasicBlocks:(uint64_t)address;
@end

@interface ReverseEngineeringViewController () <UITableViewDelegate, UITableViewDataSource, UIDocumentPickerDelegate, UISearchBarDelegate>

// UI Components
@property (nonatomic, strong) UISegmentedControl *modeSelector;
@property (nonatomic, strong) UITextView *mainTextView;
@property (nonatomic, strong) UITableView *tableView;
@property (nonatomic, strong) UIToolbar *toolbar;
@property (nonatomic, strong) UIProgressView *progressBar;
@property (nonatomic, strong) UILabel *progressLabel;
@property (nonatomic, strong) UISearchBar *searchBar;
@property (nonatomic, strong) NSLayoutConstraint *searchBarHeightConstraint;
@property (nonatomic, strong) UIView *statusBar;
@property (nonatomic, strong) UILabel *statusFileLabel;
@property (nonatomic, strong) UILabel *statusSizeLabel;
@property (nonatomic, strong) UILabel *statusProgressLabel;

// Analysis data
@property (nonatomic, strong) MachOAnalyzer *analyzer;
@property (nonatomic, strong) DisassemblerEngine *disasm;
@property (nonatomic, strong) CFGGenerator *cfgGenerator;
@property (nonatomic, strong) NSArray *strings;
@property (nonatomic, strong) NSData *binaryData;
@property (nonatomic, strong) ObjCAnalyzer *objcAnalyzer;
@property (nonatomic, strong) FunctionAnalyzer *functionAnalyzer;
@property (nonatomic, strong) PseudoCodeGenerator *pseudoCodeGen;
@property (nonatomic, strong) XREFManager *xrefManager;
@property (nonatomic, strong) SyntaxHighlighter *syntaxHighlighter;

// Search results
@property (nonatomic, strong) NSMutableArray *searchResults;
@property (nonatomic, assign) BOOL isSearchActive;

// Terminal for iSH filesystem access
@property (nonatomic, strong) Terminal *terminal;
@property (nonatomic, strong) NSString *binaryPath;

// Current mode
typedef NS_ENUM(NSInteger, REMode) {
    REModeDisassembly,
    REModeHex,
    REModeStrings,
    REModeSymbols,
    REModeMachO,
    REModeCFG,
    REModeDecompile,
    REModeClasses,
    REModeFunctions,
    REModeXREF
};
@property (nonatomic, assign) REMode currentMode;

// Helper methods
- (void)buildXREFsFromFunctions;
- (uint64_t)extractTargetAddressFromOperands:(NSString *)operands;
- (NSString *)resolveStringAtAddress:(uint64_t)address;
- (void)setHighlightedText:(NSString *)text;
- (void)setHighlightedText:(NSString *)text isCode:(BOOL)isCode;

@end

@implementation ReverseEngineeringViewController

- (instancetype)initWithTerminal:(Terminal *)terminal {
    if (self = [super init]) {
        self.terminal = terminal;
    }
    return self;
}

- (void)viewDidLoad {
    [super viewDidLoad];

    self.view.backgroundColor = [UIColor systemBackgroundColor];
    self.title = @"üî¨ Reverse Engineering";

    // Initialize XREF Manager and Syntax Highlighter
    self.xrefManager = [[XREFManager alloc] init];
    self.syntaxHighlighter = [[SyntaxHighlighter alloc] initWithColorScheme:SyntaxColorSchemeDark];

    [self setupUI];
    [self setupToolbar];
}

- (void)setupUI {
    // Mode selector with all analysis modes - improved with scrollable view
    NSArray *modes = @[@"Disassembly", @"Hex Editor", @"Strings", @"Symbols", @"Mach-O Info", @"CFG", @"Pseudo-code", @"Classes", @"Functions", @"XREF"];
    self.modeSelector = [[UISegmentedControl alloc] initWithItems:modes];
    self.modeSelector.selectedSegmentIndex = 0;
    [self.modeSelector addTarget:self action:@selector(modeChanged:) forControlEvents:UIControlEventValueChanged];

    // Make mode selector scrollable on smaller screens
    self.modeSelector.apportionsSegmentWidthsByContent = YES;

    // Search bar - adaptive to system theme
    self.searchBar = [[UISearchBar alloc] init];
    self.searchBar.placeholder = @"Search in code, functions, classes...";
    self.searchBar.delegate = (id<UISearchBarDelegate>)self;
    self.searchBar.alpha = 0;  // Start hidden with alpha for smooth animation
    self.searchBar.searchBarStyle = UISearchBarStyleMinimal;
    self.searchBar.barTintColor = [UIColor systemBackgroundColor];
    self.searchBar.backgroundColor = [UIColor systemBackgroundColor];

    // Adaptive colors that work with system theme
    if (@available(iOS 13.0, *)) {
        self.searchBar.searchTextField.backgroundColor = [UIColor secondarySystemBackgroundColor];
        self.searchBar.searchTextField.textColor = [UIColor labelColor];
        self.searchBar.searchTextField.layer.borderColor = [UIColor systemGray4Color].CGColor;
        self.searchBar.searchTextField.layer.borderWidth = 1.0;
        self.searchBar.searchTextField.layer.cornerRadius = 8.0;
        self.searchBar.searchTextField.attributedPlaceholder = [[NSAttributedString alloc] initWithString:@"Search..." attributes:@{NSForegroundColorAttributeName: [UIColor secondaryLabelColor]}];
    } else {
        UITextField *searchTextField = [self.searchBar valueForKey:@"searchField"];
        if (searchTextField) {
            searchTextField.backgroundColor = [UIColor colorWithWhite:0.95 alpha:1.0];
            searchTextField.textColor = [UIColor blackColor];
            searchTextField.layer.borderColor = [UIColor lightGrayColor].CGColor;
            searchTextField.layer.borderWidth = 1.0;
            searchTextField.layer.cornerRadius = 8.0;
        }
    }

    // Progress bar - initially visible for testing, hides after load
    self.progressBar = [[UIProgressView alloc] initWithProgressViewStyle:UIProgressViewStyleDefault];
    self.progressBar.hidden = NO;  // Start VISIBLE so you can see it
    self.progressBar.alpha = 0;    // But transparent, will fade in when needed
    self.progressBar.progressTintColor = [UIColor systemBlueColor];
    self.progressBar.trackTintColor = [UIColor systemGray5Color];
    self.progressBar.progress = 0.0;

    // Progress label - initially visible
    self.progressLabel = [[UILabel alloc] init];
    self.progressLabel.font = [UIFont systemFontOfSize:13 weight:UIFontWeightMedium];
    self.progressLabel.textAlignment = NSTextAlignmentCenter;
    self.progressLabel.textColor = [UIColor labelColor];
    self.progressLabel.hidden = NO;  // Start VISIBLE
    self.progressLabel.alpha = 0;    // But transparent
    self.progressLabel.text = @"Ready to analyze...";

    // Main text view for disassembly/hex/decompile - improved with better scrolling
    self.mainTextView = [[UITextView alloc] init];
    self.mainTextView.font = [UIFont fontWithName:@"Menlo" size:12];
    self.mainTextView.editable = NO;
    self.mainTextView.backgroundColor = [UIColor colorWithRed:0.1 green:0.1 blue:0.12 alpha:1.0];
    self.mainTextView.textColor = [UIColor colorWithRed:0.8 green:0.9 blue:1.0 alpha:1.0];
    self.mainTextView.alwaysBounceVertical = YES;  // Better scrolling
    self.mainTextView.showsVerticalScrollIndicator = YES;

    // Table view for symbols/strings/sections - improved scrolling
    self.tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain];
    self.tableView.delegate = self;
    self.tableView.dataSource = self;
    self.tableView.hidden = YES;
    self.tableView.rowHeight = UITableViewAutomaticDimension;
    self.tableView.estimatedRowHeight = 60;

    // Status Bar - ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ´ÿßÿ®ÿ™ ŸÅŸä ÿßŸÑÿ£ÿ≥ŸÅŸÑ
    self.statusBar = [[UIView alloc] init];
    self.statusBar.backgroundColor = [UIColor colorWithRed:0.15 green:0.15 blue:0.17 alpha:0.95];
    self.statusBar.layer.borderColor = [UIColor colorWithRed:0.3 green:0.3 blue:0.35 alpha:1.0].CGColor;
    self.statusBar.layer.borderWidth = 0.5;

    // File name label
    self.statusFileLabel = [[UILabel alloc] init];
    self.statusFileLabel.font = [UIFont systemFontOfSize:11 weight:UIFontWeightMedium];
    self.statusFileLabel.textColor = [UIColor colorWithRed:0.4 green:0.8 blue:1.0 alpha:1.0];
    self.statusFileLabel.text = @"No file loaded";

    // File size label
    self.statusSizeLabel = [[UILabel alloc] init];
    self.statusSizeLabel.font = [UIFont systemFontOfSize:11];
    self.statusSizeLabel.textColor = [UIColor colorWithRed:0.7 green:0.9 blue:0.7 alpha:1.0];
    self.statusSizeLabel.text = @"";

    // Progress label (ŸÅŸä ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™)
    self.statusProgressLabel = [[UILabel alloc] init];
    self.statusProgressLabel.font = [UIFont systemFontOfSize:11];
    self.statusProgressLabel.textColor = [UIColor colorWithRed:1.0 green:0.8 blue:0.4 alpha:1.0];
    self.statusProgressLabel.textAlignment = NSTextAlignmentRight;
    self.statusProgressLabel.text = @"Ready";

    [self.statusBar addSubview:self.statusFileLabel];
    [self.statusBar addSubview:self.statusSizeLabel];
    [self.statusBar addSubview:self.statusProgressLabel];

    // Layout
    self.modeSelector.translatesAutoresizingMaskIntoConstraints = NO;
    self.searchBar.translatesAutoresizingMaskIntoConstraints = NO;
    self.progressBar.translatesAutoresizingMaskIntoConstraints = NO;
    self.progressLabel.translatesAutoresizingMaskIntoConstraints = NO;
    self.mainTextView.translatesAutoresizingMaskIntoConstraints = NO;
    self.tableView.translatesAutoresizingMaskIntoConstraints = NO;
    self.statusBar.translatesAutoresizingMaskIntoConstraints = NO;
    self.statusFileLabel.translatesAutoresizingMaskIntoConstraints = NO;
    self.statusSizeLabel.translatesAutoresizingMaskIntoConstraints = NO;
    self.statusProgressLabel.translatesAutoresizingMaskIntoConstraints = NO;

    [self.view addSubview:self.modeSelector];
    [self.view addSubview:self.searchBar];
    [self.view addSubview:self.progressBar];
    [self.view addSubview:self.progressLabel];
    [self.view addSubview:self.mainTextView];
    [self.view addSubview:self.tableView];
    [self.view addSubview:self.statusBar];

    // Search bar height constraint (0 when hidden, 56 when visible)
    self.searchBarHeightConstraint = [self.searchBar.heightAnchor constraintEqualToConstant:0];

    [NSLayoutConstraint activateConstraints:@[
        // Search bar - at the top, collapsed by default
        [self.searchBar.topAnchor constraintEqualToAnchor:self.view.safeAreaLayoutGuide.topAnchor],
        [self.searchBar.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor],
        [self.searchBar.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],
        self.searchBarHeightConstraint,

        // Mode selector - below search bar (no gap)
        [self.modeSelector.topAnchor constraintEqualToAnchor:self.searchBar.bottomAnchor],
        [self.modeSelector.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor constant:8],
        [self.modeSelector.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor constant:-8],
        [self.modeSelector.heightAnchor constraintEqualToConstant:32],

        // Progress bar - AT BOTTOM of screen (above safe area)
        [self.progressBar.bottomAnchor constraintEqualToAnchor:self.view.safeAreaLayoutGuide.bottomAnchor constant:-50],
        [self.progressBar.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor constant:20],
        [self.progressBar.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor constant:-20],

        // Progress label - above progress bar
        [self.progressLabel.bottomAnchor constraintEqualToAnchor:self.progressBar.topAnchor constant:-8],
        [self.progressLabel.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor constant:20],
        [self.progressLabel.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor constant:-20],

        // Status Bar - ÿ´ÿßÿ®ÿ™ ŸÅŸä ÿßŸÑÿ£ÿ≥ŸÅŸÑ
        [self.statusBar.bottomAnchor constraintEqualToAnchor:self.view.safeAreaLayoutGuide.bottomAnchor],
        [self.statusBar.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor],
        [self.statusBar.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],
        [self.statusBar.heightAnchor constraintEqualToConstant:28],

        // Status labels inside status bar
        [self.statusFileLabel.leadingAnchor constraintEqualToAnchor:self.statusBar.leadingAnchor constant:12],
        [self.statusFileLabel.centerYAnchor constraintEqualToAnchor:self.statusBar.centerYAnchor],
        [self.statusFileLabel.widthAnchor constraintLessThanOrEqualToConstant:200],

        [self.statusSizeLabel.leadingAnchor constraintEqualToAnchor:self.statusFileLabel.trailingAnchor constant:12],
        [self.statusSizeLabel.centerYAnchor constraintEqualToAnchor:self.statusBar.centerYAnchor],

        [self.statusProgressLabel.trailingAnchor constraintEqualToAnchor:self.statusBar.trailingAnchor constant:-12],
        [self.statusProgressLabel.centerYAnchor constraintEqualToAnchor:self.statusBar.centerYAnchor],
        [self.statusProgressLabel.widthAnchor constraintLessThanOrEqualToConstant:180],

        // Main text view - below mode selector, ABOVE status bar
        [self.mainTextView.topAnchor constraintEqualToAnchor:self.modeSelector.bottomAnchor constant:8],
        [self.mainTextView.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor],
        [self.mainTextView.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],
        [self.mainTextView.bottomAnchor constraintEqualToAnchor:self.statusBar.topAnchor],

        // Table view - same position as text view
        [self.tableView.topAnchor constraintEqualToAnchor:self.modeSelector.bottomAnchor constant:8],
        [self.tableView.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor],
        [self.tableView.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],
        [self.tableView.bottomAnchor constraintEqualToAnchor:self.statusBar.topAnchor]
    ]];
}

- (void)setupToolbar {
    // Close button on left
    UIBarButtonItem *closeButton = [[UIBarButtonItem alloc] initWithTitle:@"Close" style:UIBarButtonItemStylePlain target:self action:@selector(closeTapped)];
    self.navigationItem.leftBarButtonItem = closeButton;

    // Action buttons on right
    UIBarButtonItem *searchButton = [[UIBarButtonItem alloc] initWithTitle:@"Search" style:UIBarButtonItemStylePlain target:self action:@selector(toggleSearch)];
    UIBarButtonItem *loadButton = [[UIBarButtonItem alloc] initWithTitle:@"Load" style:UIBarButtonItemStylePlain target:self action:@selector(loadBinaryTapped)];
    UIBarButtonItem *exportButton = [[UIBarButtonItem alloc] initWithTitle:@"Export" style:UIBarButtonItemStylePlain target:self action:@selector(exportTapped)];
    UIBarButtonItem *patchButton = [[UIBarButtonItem alloc] initWithTitle:@"Patch" style:UIBarButtonItemStylePlain target:self action:@selector(patchTapped)];
    UIBarButtonItem *jumpButton = [[UIBarButtonItem alloc] initWithTitle:@"Jump to..." style:UIBarButtonItemStylePlain target:self action:@selector(jumpToAddressTapped)];

    self.navigationItem.rightBarButtonItems = @[exportButton, patchButton, jumpButton, loadButton, searchButton];
}

- (void)closeTapped {
    [self dismissViewControllerAnimated:YES completion:nil];
}

- (void)jumpToAddressTapped {
    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"Jump to Address/Function"
                                                                   message:@"Enter address (0x100001234) or function name (sub_100028420)"
                                                            preferredStyle:UIAlertControllerStyleAlert];

    [alert addTextFieldWithConfigurationHandler:^(UITextField *textField) {
        textField.placeholder = @"0x100028420 or sub_100028420";
        textField.autocapitalizationType = UITextAutocapitalizationTypeNone;
        textField.autocorrectionType = UITextAutocorrectionTypeNo;
    }];

    [alert addAction:[UIAlertAction actionWithTitle:@"Jump" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        NSString *input = alert.textFields.firstObject.text;
        [self jumpToFunction:input];
    }]];

    [alert addAction:[UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:nil]];

    [self presentViewController:alert animated:YES completion:nil];
}

- (void)jumpToFunction:(NSString *)input {
    if (!input || input.length == 0) return;

    input = [input stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];

    // Try to parse as hex address
    uint64_t address = 0;
    if ([input hasPrefix:@"0x"]) {
        NSScanner *scanner = [NSScanner scannerWithString:input];
        [scanner setScanLocation:2]; // Skip "0x"
        unsigned long long scannedValue;
        if ([scanner scanHexLongLong:&scannedValue]) {
            address = scannedValue;
        }
    } else if ([input hasPrefix:@"sub_"]) {
        // Parse sub_XXXXXXXX format
        NSString *hexPart = [input substringFromIndex:4]; // Skip "sub_"
        NSScanner *scanner = [NSScanner scannerWithString:hexPart];
        unsigned long long scannedValue;
        if ([scanner scanHexLongLong:&scannedValue]) {
            address = scannedValue;
        }
    }

    if (address > 0 && self.functionAnalyzer) {
        // Find function at this address
        DetectedFunction *function = [self.functionAnalyzer functionAtAddress:address];
        if (function) {
            [self showFunctionDetails:function];
        } else {
            UIAlertController *notFound = [UIAlertController alertControllerWithTitle:@"Not Found"
                                                                              message:[NSString stringWithFormat:@"No function found at address 0x%llx", address]
                                                                       preferredStyle:UIAlertControllerStyleAlert];
            [notFound addAction:[UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:nil]];
            [self presentViewController:notFound animated:YES completion:nil];
        }
    } else {
        UIAlertController *invalid = [UIAlertController alertControllerWithTitle:@"Invalid Input"
                                                                          message:@"Please enter a valid address (0x100028420) or function name (sub_100028420)"
                                                                   preferredStyle:UIAlertControllerStyleAlert];
        [invalid addAction:[UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:nil]];
        [self presentViewController:invalid animated:YES completion:nil];
    }
}

- (void)toggleSearch {
    BOOL isShowing = (self.searchBarHeightConstraint.constant > 0);

    [UIView animateWithDuration:0.3 animations:^{
        if (isShowing) {
            // Hide search bar
            self.searchBarHeightConstraint.constant = 0;
            self.searchBar.alpha = 0;
            [self.view layoutIfNeeded];
        } else {
            // Show search bar
            self.searchBarHeightConstraint.constant = 56;
            self.searchBar.alpha = 1;
            [self.view layoutIfNeeded];
        }
    } completion:^(BOOL finished) {
        if (!isShowing) {
            [self.searchBar becomeFirstResponder];
        } else {
            [self.searchBar resignFirstResponder];
            self.searchBar.text = @"";
            self.searchResults = nil;
            [self refreshView];
        }
    }];
}

- (void)modeChanged:(UISegmentedControl *)sender {
    self.currentMode = sender.selectedSegmentIndex;
    [self refreshView];
}

- (void)refreshView {
    switch (self.currentMode) {
        case REModeDisassembly:
            self.mainTextView.hidden = NO;
            self.tableView.hidden = YES;
            [self disassemble];
            break;
        case REModeHex:
            self.mainTextView.hidden = NO;
            self.tableView.hidden = YES;
            [self showHexView];
            break;
        case REModeStrings:
            self.mainTextView.hidden = YES;
            self.tableView.hidden = NO;
            [self extractStrings];
            [self.tableView reloadData];
            break;
        case REModeSymbols:
            self.mainTextView.hidden = YES;
            self.tableView.hidden = NO;
            [self.tableView reloadData];
            break;
        case REModeMachO:
            self.mainTextView.hidden = NO;
            self.tableView.hidden = YES;
            [self analyzeMachO];
            break;
        case REModeCFG:
            self.mainTextView.hidden = NO;
            self.tableView.hidden = YES;
            [self showCFG];
            break;
        case REModeDecompile:
            self.mainTextView.hidden = NO;
            self.tableView.hidden = YES;
            [self decompile];
            break;
        case REModeClasses:
            self.mainTextView.hidden = YES;
            self.tableView.hidden = NO;
            [self showObjCClasses];
            [self.tableView reloadData];
            break;
        case REModeFunctions:
            self.mainTextView.hidden = YES;
            self.tableView.hidden = NO;
            [self showFunctions];
            [self.tableView reloadData];
            break;
        case REModeXREF:
            self.mainTextView.hidden = YES;
            self.tableView.hidden = NO;
            [self showXREF];
            [self.tableView reloadData];
            break;
    }
}

#pragma mark - Load Binary

- (void)loadBinaryTapped {
    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"Load Binary"
                                                                   message:@"Choose an option:"
                                                            preferredStyle:UIAlertControllerStyleActionSheet];

    // Option 1: Upload from Files app (RECOMMENDED)
    [alert addAction:[UIAlertAction actionWithTitle:@"Upload from Files App" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        [self showDocumentPicker];
    }]];

    // Option 2: Browse files
    [alert addAction:[UIAlertAction actionWithTitle:@"Browse iSH Filesystem" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        [self showFileBrowser];
    }]];

    // Option 3: Enter path manually
    [alert addAction:[UIAlertAction actionWithTitle:@"Enter Path Manually" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        [self showManualPathEntry];
    }]];

    // Option 4: Quick load common binaries
    [alert addAction:[UIAlertAction actionWithTitle:@"Quick Load (/bin/ls)" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        [self loadBinary:@"/bin/ls"];
    }]];

    [alert addAction:[UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:nil]];

    [self presentViewController:alert animated:YES completion:nil];
}

- (void)showDocumentPicker {
    UIDocumentPickerViewController *documentPicker = [[UIDocumentPickerViewController alloc] initWithDocumentTypes:@[@"public.data", @"public.content", @"public.item"] inMode:UIDocumentPickerModeImport];
    documentPicker.delegate = self;
    documentPicker.allowsMultipleSelection = NO;

    if (@available(iOS 13.0, *)) {
        documentPicker.shouldShowFileExtensions = YES;
    }

    [self presentViewController:documentPicker animated:YES completion:nil];
}

#pragma mark - UIDocumentPickerDelegate

- (void)documentPicker:(UIDocumentPickerViewController *)controller didPickDocumentsAtURLs:(NSArray<NSURL *> *)urls {
    if (urls.count == 0) return;

    NSURL *url = urls.firstObject;
    NSError *error = nil;
    NSData *fileData = nil;

    // Try method 1: Direct access without security scope (for local files)
    fileData = [NSData dataWithContentsOfURL:url options:NSDataReadingMappedIfSafe error:&error];

    // Try method 2: With security scoped access (for iCloud/external files)
    if (!fileData) {
        error = nil;
        BOOL hasAccess = [url startAccessingSecurityScopedResource];
        fileData = [NSData dataWithContentsOfURL:url options:NSDataReadingMappedIfSafe error:&error];
        if (hasAccess) {
            [url stopAccessingSecurityScopedResource];
        }
    }

    // Try method 3: Copy to temp location first
    if (!fileData) {
        error = nil;
        NSString *tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:url.lastPathComponent];

        BOOL hasAccess = [url startAccessingSecurityScopedResource];
        BOOL copySuccess = [[NSFileManager defaultManager] copyItemAtURL:url toURL:[NSURL fileURLWithPath:tempPath] error:&error];
        if (hasAccess) {
            [url stopAccessingSecurityScopedResource];
        }

        if (copySuccess) {
            fileData = [NSData dataWithContentsOfFile:tempPath];
            [[NSFileManager defaultManager] removeItemAtPath:tempPath error:nil];
        }
    }

    if (!fileData || fileData.length == 0) {
        NSString *errorMsg = error ? error.localizedDescription : @"Unknown error";
        NSString *urlInfo = [NSString stringWithFormat:@"URL: %@\nScheme: %@\nPath: %@",
                            url.absoluteString, url.scheme, url.path];

        UIAlertController *detailAlert = [UIAlertController alertControllerWithTitle:@"‚ùå Cannot Access File"
                                                                              message:[NSString stringWithFormat:
                                                                                      @"Error: %@\n\n"
                                                                                      @"%@\n\n"
                                                                                      @"‚ö†Ô∏è iSH files cannot be accessed directly\n\n"
                                                                                      @"‚úÖ Solution:\n"
                                                                                      @"1. In terminal: cp ChatBYE ~/chatbye_copy\n"
                                                                                      @"2. Use Share in Files app\n"
                                                                                      @"3. Save to iCloud Drive\n"
                                                                                      @"4. Then select from iCloud",
                                                                                      errorMsg, urlInfo]
                                                                       preferredStyle:UIAlertControllerStyleAlert];
        [detailAlert addAction:[UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:nil]];
        [self presentViewController:detailAlert animated:YES completion:nil];
        return;
    }

    // Success! Load the binary with progressive loading
    self.binaryPath = url.lastPathComponent;
    self.binaryData = fileData;

    // Show progress bar
    self.progressBar.hidden = NO;
    self.progressLabel.hidden = NO;
    self.progressBar.progress = 0.0;

    // Progressive loading with colored progress (Blue -> Green -> Red like Hopper)
    [self loadBinaryProgressively:url fileName:url.lastPathComponent];

}

- (void)documentPickerWasCancelled:(UIDocumentPickerViewController *)controller {
    // User cancelled - do nothing
}

- (void)loadBinaryProgressively:(NSURL *)url fileName:(NSString *)fileName {
    // Progressive loading with colored progress bar (Blue -> Green -> Red like Hopper)

    // Show progress UI immediately with fade in animation
    dispatch_async(dispatch_get_main_queue(), ^{
        self.progressBar.hidden = NO;
        self.progressLabel.hidden = NO;
        self.progressBar.progress = 0.0;
        self.progressLabel.text = @"Starting analysis...";

        // Fade in animation
        [UIView animateWithDuration:0.3 animations:^{
            self.progressBar.alpha = 1.0;
            self.progressLabel.alpha = 1.0;
        }];
    });

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        __block float progress = 0.0;

        // Check file size for chunking strategy
        NSUInteger fileSize = self.binaryData.length;
        BOOL isLargeFile = (fileSize > 50 * 1024 * 1024); // 50 MB threshold

        // Phase 1: Mach-O Analysis (Blue) - 0% to 20%
        dispatch_async(dispatch_get_main_queue(), ^{
            NSString *sizeInfo = isLargeFile ? @" (Large file - chunked analysis)" : @"";
            self.progressLabel.text = [NSString stringWithFormat:@"Analyzing Mach-O structure...%@", sizeInfo];
            self.progressBar.progressTintColor = [UIColor systemBlueColor];
        });

        self.analyzer = [[MachOAnalyzer alloc] initWithData:self.binaryData];

        // Chunked analysis for large files
        if (isLargeFile) {
            // Process in smaller chunks with progress updates
            for (int i = 0; i < 5; i++) {
                usleep(100000); // 0.1 second per chunk
                progress = 0.04 * (i + 1); // Incremental progress
                dispatch_async(dispatch_get_main_queue(), ^{
                    self.progressBar.progress = progress;
                });
            }
        }

        [self.analyzer analyze];

        progress = 0.2;
        dispatch_async(dispatch_get_main_queue(), ^{
            [UIView animateWithDuration:0.3 animations:^{
                self.progressBar.progress = progress;
            }];
        });

        usleep(200000); // 0.2 second delay for visual effect

        // Phase 2: Disassembler Setup (Green) - 20% to 40%
        dispatch_async(dispatch_get_main_queue(), ^{
            self.progressLabel.text = @"Setting up disassembler...";
            self.progressBar.progressTintColor = [UIColor systemGreenColor];
        });

        self.disasm = [[DisassemblerEngine alloc] init];
        self.disasm.codeData = self.binaryData;
        self.cfgGenerator = [[CFGGenerator alloc] init];
        self.cfgGenerator.engine = self.disasm;

        progress = 0.4;
        dispatch_async(dispatch_get_main_queue(), ^{
            [UIView animateWithDuration:0.3 animations:^{
                self.progressBar.progress = progress;
            }];
        });

        usleep(200000);

        // Phase 3: Objective-C Analysis (Orange) - 40% to 60%
        dispatch_async(dispatch_get_main_queue(), ^{
            self.progressLabel.text = @"Extracting Objective-C classes...";
            self.progressBar.progressTintColor = [UIColor systemOrangeColor];
        });

        self.objcAnalyzer = [[ObjCAnalyzer alloc] initWithBinaryData:self.binaryData baseAddress:0x100000000];

        // Chunked ObjC analysis for large files
        if (isLargeFile) {
            for (int i = 0; i < 5; i++) {
                if (i == 2) {
                    [self.objcAnalyzer analyze]; // Analyze in the middle
                }
                usleep(100000);
                progress = 0.4 + (0.04 * (i + 1));
                dispatch_async(dispatch_get_main_queue(), ^{
                    self.progressBar.progress = progress;
                    self.progressLabel.text = [NSString stringWithFormat:@"Extracting Objective-C classes... %d%%", (int)(progress * 100)];
                });
            }
        } else {
            [self.objcAnalyzer analyze];
        }

        progress = 0.6;
        dispatch_async(dispatch_get_main_queue(), ^{
            [UIView animateWithDuration:0.3 animations:^{
                self.progressBar.progress = progress;
            }];
        });

        usleep(200000);

        // Phase 4: Function Detection (Red) - 60% to 80%
        dispatch_async(dispatch_get_main_queue(), ^{
            self.progressLabel.text = @"Detecting functions...";
            self.progressBar.progressTintColor = [UIColor systemRedColor];
        });

        self.functionAnalyzer = [[FunctionAnalyzer alloc] initWithBinaryData:self.binaryData baseAddress:0x100000000];

        // Analyze with real-time progress updates
        [self.functionAnalyzer analyzeWithProgressBlock:^(float analysisProgress, NSString *message) {
            // Map analysis progress (0.0-1.0) to our phase range (60%-80%)
            float mappedProgress = 0.6 + (analysisProgress * 0.2);

            dispatch_async(dispatch_get_main_queue(), ^{
                self.progressBar.progress = mappedProgress;
                self.progressLabel.text = message;
            });
        }];

        progress = 0.8;
        dispatch_async(dispatch_get_main_queue(), ^{
            [UIView animateWithDuration:0.3 animations:^{
                self.progressBar.progress = progress;
            }];
        });

        usleep(200000);

        // Phase 5: Strings Extraction - 80% to 85%
        dispatch_async(dispatch_get_main_queue(), ^{
            self.progressLabel.text = @"Extracting strings...";
            self.progressBar.progressTintColor = [UIColor systemYellowColor];
        });

        [self extractStrings];

        progress = 0.85;
        dispatch_async(dispatch_get_main_queue(), ^{
            [UIView animateWithDuration:0.3 animations:^{
                self.progressBar.progress = progress;
            }];
        });

        usleep(200000);

        // Phase 6: Linking & Cross-References (Purple) - 85% to 100%
        dispatch_async(dispatch_get_main_queue(), ^{
            self.progressLabel.text = @"Building cross-references...";
            self.progressBar.progressTintColor = [UIColor systemPurpleColor];
        });

        // Build XREFs from detected functions
        [self.xrefManager clear];
        [self buildXREFsFromFunctions];

        progress = 0.9;
        dispatch_async(dispatch_get_main_queue(), ^{
            self.progressBar.progress = progress;
            self.progressLabel.text = @"Linking cross-references...";
        });

        // Link ObjC methods to detected functions
        NSUInteger totalClasses = self.objcAnalyzer.classes.count;
        NSUInteger processedClasses = 0;

        for (ObjCClass *objcClass in self.objcAnalyzer.classes) {
            for (ObjCMethod *method in objcClass.instanceMethods) {
                [self.functionAnalyzer linkObjCMethod:method.name
                                            className:objcClass.className
                                            toAddress:method.implementation];
            }
            for (ObjCMethod *method in objcClass.classMethods) {
                [self.functionAnalyzer linkObjCMethod:method.name
                                            className:objcClass.className
                                            toAddress:method.implementation];
            }

            // Update progress for large files
            processedClasses++;
            if (isLargeFile && totalClasses > 0 && processedClasses % (totalClasses / 10 + 1) == 0) {
                progress = 0.8 + (0.2 * ((float)processedClasses / totalClasses));
                dispatch_async(dispatch_get_main_queue(), ^{
                    self.progressBar.progress = progress;
                    self.progressLabel.text = [NSString stringWithFormat:@"Building cross-references... %d%%", (int)(progress * 100)];
                });
            }
        }

        // Initialize pseudo-code generator and build string map
        self.pseudoCodeGen = [[PseudoCodeGenerator alloc] init];

        dispatch_async(dispatch_get_main_queue(), ^{
            self.progressLabel.text = @"Building string map for pseudo-code...";
            self.progressBar.progress = 0.95;
        });

        // Build string map for resolving addresses to strings in pseudo-code
        [self.pseudoCodeGen buildStringMapFromBinaryData:self.binaryData baseAddress:0x100000000];

        progress = 1.0;
        dispatch_async(dispatch_get_main_queue(), ^{
            [UIView animateWithDuration:0.3 animations:^{
                self.progressBar.progress = progress;
            } completion:^(BOOL finished) {
                // Hide progress bar after a short delay with fade out
                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                    [UIView animateWithDuration:0.5 animations:^{
                        self.progressBar.alpha = 0.0;
                        self.progressLabel.alpha = 0.0;
                    } completion:^(BOOL finished) {
                        self.progressBar.hidden = YES;
                        self.progressLabel.hidden = YES;
                    }];

                    // Update title and refresh view
                    self.title = [NSString stringWithFormat:@"üî¨ %@", fileName];
                    [self refreshView];

                    // Show comprehensive success message
                    NSString *classInfo = self.objcAnalyzer.classes.count > 0 ?
                        [NSString stringWithFormat:@"\nüéØ %lu Objective-C classes", (unsigned long)self.objcAnalyzer.classes.count] : @"";
                    NSString *funcInfo = self.functionAnalyzer.functions.count > 0 ?
                        [NSString stringWithFormat:@"\n‚öôÔ∏è %lu functions detected", (unsigned long)self.functionAnalyzer.functions.count] : @"";
                    NSString *stringsInfo = self.strings.count > 0 ?
                        [NSString stringWithFormat:@"\nüìù %lu strings extracted", (unsigned long)self.strings.count] : @"";
                    NSString *xrefInfo = self.functionAnalyzer.crossReferences.count > 0 ?
                        [NSString stringWithFormat:@"\nüîó %lu cross-references", (unsigned long)self.functionAnalyzer.crossReferences.count] : @"";

                    UIAlertController *successAlert = [UIAlertController alertControllerWithTitle:@"‚úÖ Complete Analysis!"
                                                                                           message:[NSString stringWithFormat:@"üìÅ %@\nüìä %.2f MB%@%@%@%@\n\nüî¨ Fully Analyzed!",
                                                                                                   fileName,
                                                                                                   self.binaryData.length / 1024.0 / 1024.0,
                                                                                                   classInfo, funcInfo, stringsInfo, xrefInfo]
                                                                                    preferredStyle:UIAlertControllerStyleAlert];
                    [successAlert addAction:[UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:nil]];
                    [self presentViewController:successAlert animated:YES completion:nil];
                });
            }];
        });
    });
}

- (void)showManualPathEntry {
    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"Enter Binary Path"
                                                                   message:@"Full path to executable binary:"
                                                            preferredStyle:UIAlertControllerStyleAlert];

    [alert addTextFieldWithConfigurationHandler:^(UITextField *textField) {
        textField.placeholder = @"/bin/ls or /root/Payload/App.app/App";
        textField.text = @"/bin/ls";
        textField.autocapitalizationType = UITextAutocapitalizationTypeNone;
        textField.autocorrectionType = UITextAutocorrectionTypeNo;
    }];

    [alert addAction:[UIAlertAction actionWithTitle:@"Load" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        NSString *path = alert.textFields.firstObject.text;
        [self loadBinary:path];
    }]];

    [alert addAction:[UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:nil]];

    [self presentViewController:alert animated:YES completion:nil];
}

- (void)showFileBrowser {
    UIAlertController *browser = [UIAlertController alertControllerWithTitle:@"üìÇ File Browser"
                                                                     message:@"Select a directory:"
                                                              preferredStyle:UIAlertControllerStyleActionSheet];

    // Common directories in iSH filesystem
    NSArray *commonDirs = @[
        @"/bin",
        @"/usr/bin",
        @"/root",
        @"/",
        @"/tmp"
    ];

    for (NSString *dir in commonDirs) {
        [browser addAction:[UIAlertAction actionWithTitle:dir style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
            [self browseDirectory:dir];
        }]];
    }

    [browser addAction:[UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:nil]];

    [self presentViewController:browser animated:YES completion:nil];
}

- (void)browseDirectory:(NSString *)directory {
    // Show instructions instead of trying to browse
    NSString *instructions = [NSString stringWithFormat:
        @"üì± iSH Filesystem Access\n\n"
        @"Due to iOS security, this tool cannot directly browse iSH's internal filesystem.\n\n"
        @"üìù To analyze binaries:\n\n"
        @"1Ô∏è‚É£ Open iSH Terminal\n"
        @"2Ô∏è‚É£ Extract your IPA:\n"
        @"   cd /root\n"
        @"   unzip YourApp.ipa\n\n"
        @"3Ô∏è‚É£ Find the executable:\n"
        @"   cd Payload/*.app\n"
        @"   ls -la\n\n"
        @"4Ô∏è‚É£ Share it to iOS:\n"
        @"   Option A: Copy to Files app location\n"
        @"   Option B: Use the path entry below\n\n"
        @"üí° Common paths to try:\n"
        @"‚Ä¢ /bin/ls (test file)\n"
        @"‚Ä¢ /usr/bin/python3\n"
        @"‚Ä¢ System binaries: /bin/, /usr/bin/"
    ];

    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"üìÇ File Browser"
                                                                   message:instructions
                                                            preferredStyle:UIAlertControllerStyleAlert];

    [alert addAction:[UIAlertAction actionWithTitle:@"Enter Path Manually" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        [self showManualPathEntry];
    }]];

    [alert addAction:[UIAlertAction actionWithTitle:@"Use Files App" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        [self showFilePickerInstructions];
    }]];

    [alert addAction:[UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleCancel handler:nil]];

    [self presentViewController:alert animated:YES completion:nil];
}

- (void)showFilePickerInstructions {
    NSString *msg = @"To use Files app:\n\n"
                    @"1. Extract IPA in iSH terminal\n"
                    @"2. Move file to shared location\n"
                    @"3. Import via share sheet\n\n"
                    @"For now, use manual path entry with paths accessible from terminal.";

    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"Files App Access"
                                                                   message:msg
                                                            preferredStyle:UIAlertControllerStyleAlert];
    [alert addAction:[UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:nil]];
    [self presentViewController:alert animated:YES completion:nil];
}

- (void)loadBinary:(NSString *)path {
    self.binaryPath = path;

    // Check if IPA file first
    if ([path.pathExtension.lowercaseString isEqualToString:@"ipa"]) {
        // Show IPA extraction instructions
        [self autoExtractIPA:path];
        return;
    }

    // Show loading indicator
    UIAlertController *loadingAlert = [UIAlertController alertControllerWithTitle:@"Loading Binary"
                                                                           message:@"Reading file via iSH terminal..."
                                                                    preferredStyle:UIAlertControllerStyleAlert];
    [self presentViewController:loadingAlert animated:YES completion:nil];

    // Load file via iSH terminal using base64 encoding
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSData *binaryData = [self readFileViaTerminal:path];

        dispatch_async(dispatch_get_main_queue(), ^{
            [loadingAlert dismissViewControllerAnimated:YES completion:^{
                if (!binaryData) {
                    NSString *errorMsg = [NSString stringWithFormat:
                        @"‚ùå Cannot load file: %@\n\n"
                        @"Possible reasons:\n"
                        @"‚Ä¢ File doesn't exist\n"
                        @"‚Ä¢ Path is incorrect\n"
                        @"‚Ä¢ File is not readable\n\n"
                        @"üí° Tip: Verify the path in terminal:\n"
                        @"   ls -la %@",
                        path, path];
                    [self showError:errorMsg];
                    return;
                }

                self.binaryData = binaryData;

                if (self.binaryData.length == 0) {
                    [self showError:[NSString stringWithFormat:@"File is empty: %@", path]];
                    return;
                }

                // Initialize analyzer
                self.analyzer = [[MachOAnalyzer alloc] initWithData:self.binaryData];
                [self.analyzer analyze];

                // Initialize disassembler
                self.disasm = [[DisassemblerEngine alloc] init];
                self.disasm.codeData = self.binaryData;

                // Initialize CFG generator
                self.cfgGenerator = [[CFGGenerator alloc] init];
                self.cfgGenerator.engine = self.disasm;

                self.title = [NSString stringWithFormat:@"üî¨ %@", path.lastPathComponent];
                [self refreshView];
            }];
        });
    });
}

- (NSData *)readFileViaTerminal:(NSString *)path {
    // For now, show a helpful error message
    // The terminal bridge approach has limitations
    return nil;

    // TODO: Implement a proper bridge using:
    // 1. Install coreutils in iSH: apk add coreutils
    // 2. Use base64 or xxd to encode the file
    // 3. Read the output and decode it
    // 4. Or use a shared mount point between iSH and iOS
}

- (void)autoExtractIPA:(NSString *)ipaPath {
    NSString *ipaDir = [ipaPath stringByDeletingLastPathComponent];
    NSString *ipaName = [ipaPath lastPathComponent];

    NSString *instructions = [NSString stringWithFormat:
        @"üì¶ IPA Extraction Required\n\n"
        @"To analyze this IPA:\n\n"
        @"1Ô∏è‚É£ Open iSH Terminal\n\n"
        @"2Ô∏è‚É£ Install unzip (if not installed):\n"
        @"   apk add unzip\n\n"
        @"3Ô∏è‚É£ Navigate to IPA directory:\n"
        @"   cd %@\n\n"
        @"4Ô∏è‚É£ Extract the IPA:\n"
        @"   unzip -o '%@'\n\n"
        @"5Ô∏è‚É£ Find the executable:\n"
        @"   cd Payload/*.app\n"
        @"   ls -la\n\n"
        @"6Ô∏è‚É£ Note the executable path, then come back and load it using:\n"
        @"   üìÇ Load Binary ‚Üí ‚å®Ô∏è Enter Path Manually\n\n"
        @"Example path:\n"
        @"%@/Payload/YourApp.app/YourApp",
        ipaDir, ipaName, ipaDir];

    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"üì¶ IPA Extraction"
                                                                   message:instructions
                                                            preferredStyle:UIAlertControllerStyleAlert];

    [alert addAction:[UIAlertAction actionWithTitle:@"I've Extracted It" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        [self showManualPathEntry];
    }]];

    [alert addAction:[UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleCancel handler:nil]];

    [self presentViewController:alert animated:YES completion:nil];
}

- (void)loadIPA:(NSString *)ipaPath {
    // Show progress dialog
    UIAlertController *progressAlert = [UIAlertController alertControllerWithTitle:@"üì¶ Analyzing IPA"
                                                                           message:@"Step 1/6: Extracting archive..."
                                                                    preferredStyle:UIAlertControllerStyleAlert];

    UIProgressView *progressBar = [[UIProgressView alloc] initWithProgressViewStyle:UIProgressViewStyleDefault];
    progressBar.frame = CGRectMake(20, 70, 230, 2);
    [progressAlert.view addSubview:progressBar];

    [self presentViewController:progressAlert animated:YES completion:nil];

    // Run analysis in background
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSMutableString *output = [NSMutableString stringWithString:@"‚ïê‚ïê‚ïê IPA ANALYSIS ‚ïê‚ïê‚ïê\n\n"];
        [output appendFormat:@"Path: %@\n\n", ipaPath];

        // Step 1: Extract IPA (20%)
        dispatch_async(dispatch_get_main_queue(), ^{
            progressAlert.message = @"Step 1/6: Extracting IPA archive...";
            progressBar.progress = 0.16;
        });

        NSString *tmpDir = [self extractIPA:ipaPath output:output];
        if (!tmpDir) {
            // IPA needs manual extraction - show instructions
            dispatch_async(dispatch_get_main_queue(), ^{
                [progressAlert dismissViewControllerAnimated:YES completion:^{
                    [self setHighlightedText:output isCode:YES];
                    self.title = @"üî¨ IPA Extraction Required";
                }];
            });
            return;
        }

        // Step 2: Find main executable (40%)
        dispatch_async(dispatch_get_main_queue(), ^{
            progressAlert.message = @"Step 2/6: Locating main executable...";
            progressBar.progress = 0.33;
        });

        NSString *executablePath = [self findMainExecutable:tmpDir output:output];

        // Step 3: Parse Info.plist (60%)
        dispatch_async(dispatch_get_main_queue(), ^{
            progressAlert.message = @"Step 3/6: Parsing Info.plist...";
            progressBar.progress = 0.50;
        });

        [self parseInfoPlist:tmpDir output:output];

        // Step 4: List frameworks (70%)
        dispatch_async(dispatch_get_main_queue(), ^{
            progressAlert.message = @"Step 4/6: Analyzing frameworks...";
            progressBar.progress = 0.66;
        });

        [self listFrameworks:tmpDir output:output];

        // Step 5: Extract entitlements (85%)
        dispatch_async(dispatch_get_main_queue(), ^{
            progressAlert.message = @"Step 5/6: Extracting entitlements...";
            progressBar.progress = 0.83;
        });

        [self extractEntitlements:executablePath output:output];

        // Step 6: List plugins (100%)
        dispatch_async(dispatch_get_main_queue(), ^{
            progressAlert.message = @"Step 6/6: Analyzing plugins & extensions...";
            progressBar.progress = 1.0;
        });

        [self listPlugins:tmpDir output:output];

        // Load main executable
        if (executablePath) {
            [self loadBinary:executablePath];
        }

        // Done - show results
        dispatch_async(dispatch_get_main_queue(), ^{
            [progressAlert dismissViewControllerAnimated:YES completion:^{
                [self setHighlightedText:output isCode:YES];
                self.title = [NSString stringWithFormat:@"üî¨ %@", ipaPath.lastPathComponent];
            }];
        });
    });
}

- (NSString *)extractIPA:(NSString *)ipaPath output:(NSMutableString *)output {
    [output appendString:@"‚ïê‚ïê‚ïê STEP 1: EXTRACTION ‚ïê‚ïê‚ïê\n\n"];
    [output appendFormat:@"IPA Path: %@\n\n", ipaPath];

    // Strategy 1: Check if Payload exists in same directory as IPA
    NSString *ipaDir = [ipaPath stringByDeletingLastPathComponent];
    NSString *checkPayload = [ipaDir stringByAppendingPathComponent:@"Payload"];

    [output appendFormat:@"üîç Checking: %@\n", checkPayload];
    BOOL isDir = NO;
    BOOL exists = [[NSFileManager defaultManager] fileExistsAtPath:checkPayload isDirectory:&isDir];

    if (exists && isDir) {
        [output appendString:@"‚úÖ Found extracted Payload directory!\n\n"];
        return ipaDir;
    } else {
        [output appendFormat:@"   Result: %@ (isDir: %@)\n\n", exists ? @"EXISTS" : @"NOT FOUND", isDir ? @"YES" : @"NO"];
    }

    // Strategy 2: Check if IPA path without extension has Payload inside
    NSString *ipaAsDir = [ipaPath stringByDeletingPathExtension];
    NSString *payloadInIPA = [ipaAsDir stringByAppendingPathComponent:@"Payload"];

    [output appendFormat:@"üîç Checking: %@\n", payloadInIPA];
    exists = [[NSFileManager defaultManager] fileExistsAtPath:payloadInIPA isDirectory:&isDir];

    if (exists && isDir) {
        [output appendString:@"‚úÖ Found Payload in IPA directory!\n\n"];
        return ipaAsDir;
    } else {
        [output appendFormat:@"   Result: %@ (isDir: %@)\n\n", exists ? @"EXISTS" : @"NOT FOUND", isDir ? @"YES" : @"NO"];
    }

    // Strategy 3: Check /root/Payload directly
    NSString *rootPayload = @"/root/Payload";

    [output appendFormat:@"üîç Checking: %@\n", rootPayload];
    exists = [[NSFileManager defaultManager] fileExistsAtPath:rootPayload isDirectory:&isDir];

    if (exists && isDir) {
        [output appendString:@"‚úÖ Found Payload in /root!\n\n"];
        return @"/root";
    } else {
        [output appendFormat:@"   Result: %@ (isDir: %@)\n\n", exists ? @"EXISTS" : @"NOT FOUND", isDir ? @"YES" : @"NO"];
    }

    // Strategy 4: List what's actually in the IPA directory
    [output appendString:@"üìÅ Contents of IPA directory:\n"];
    NSError *error = nil;
    NSArray *contents = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:ipaDir error:&error];

    if (error) {
        [output appendFormat:@"   Error: %@\n\n", error.localizedDescription];
    } else {
        for (NSString *item in contents) {
            NSString *fullPath = [ipaDir stringByAppendingPathComponent:item];
            BOOL itemIsDir = NO;
            [[NSFileManager defaultManager] fileExistsAtPath:fullPath isDirectory:&itemIsDir];
            [output appendFormat:@"   %@ %@\n", itemIsDir ? @"üìÅ" : @"üìÑ", item];
        }
        [output appendString:@"\n"];
    }

    // IPA needs manual extraction
    [output appendString:@"‚ö†Ô∏è  Could not auto-detect extracted IPA.\n\n"];
    [output appendString:@"üìù Options:\n\n"];
    [output appendString:@"OPTION 1: Manual Path Entry\n"];
    [output appendString:@"   If Payload exists, load the executable directly:\n"];
    [output appendFormat:@"   %@/Payload/[AppName].app/[AppName]\n\n", ipaDir];

    [output appendString:@"OPTION 2: Extract using Terminal\n"];
    [output appendString:@"   1. Install unzip: apk add unzip\n"];
    [output appendFormat:@"   2. Extract: cd %@ && unzip \"%@\"\n\n", ipaDir, [ipaPath lastPathComponent]];

    [output appendString:@"OPTION 3: Use File Browser\n"];
    [output appendString:@"   Tap 'üìÇ Browse Files' ‚Üí Navigate to /root ‚Üí Find .app folder\n\n"];

    // Return nil to indicate extraction needed
    return nil;
}

- (NSString *)findMainExecutable:(NSString *)tmpDir output:(NSMutableString *)output {
    [output appendString:@"‚ïê‚ïê‚ïê STEP 2: MAIN EXECUTABLE ‚ïê‚ïê‚ïê\n\n"];

    // Look for Payload/*.app/
    NSString *payloadPath = [tmpDir stringByAppendingPathComponent:@"Payload"];
    NSArray *apps = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:payloadPath error:nil];

    for (NSString *app in apps) {
        if ([app hasSuffix:@".app"]) {
            NSString *appPath = [payloadPath stringByAppendingPathComponent:app];
            NSString *appName = [app stringByDeletingPathExtension];
            NSString *executablePath = [appPath stringByAppendingPathComponent:appName];

            if ([[NSFileManager defaultManager] fileExistsAtPath:executablePath]) {
                [output appendFormat:@"‚úÖ Found: %@\n", appName];
                [output appendFormat:@"   Path: %@\n\n", executablePath];

                // Get file size
                NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:executablePath error:nil];
                unsigned long long fileSize = [attrs fileSize];
                [output appendFormat:@"   Size: %.2f MB\n\n", fileSize / 1024.0 / 1024.0];

                return executablePath;
            }
        }
    }

    [output appendString:@"‚ùå Main executable not found\n\n"];
    return nil;
}

- (void)parseInfoPlist:(NSString *)tmpDir output:(NSMutableString *)output {
    [output appendString:@"‚ïê‚ïê‚ïê STEP 3: INFO.PLIST ‚ïê‚ïê‚ïê\n\n"];

    NSString *payloadPath = [tmpDir stringByAppendingPathComponent:@"Payload"];
    NSArray *apps = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:payloadPath error:nil];

    for (NSString *app in apps) {
        if ([app hasSuffix:@".app"]) {
            NSString *appPath = [payloadPath stringByAppendingPathComponent:app];
            NSString *plistPath = [appPath stringByAppendingPathComponent:@"Info.plist"];

            if ([[NSFileManager defaultManager] fileExistsAtPath:plistPath]) {
                NSDictionary *plist = [NSDictionary dictionaryWithContentsOfFile:plistPath];

                if (plist) {
                    [output appendFormat:@"Bundle ID: %@\n", plist[@"CFBundleIdentifier"] ?: @"N/A"];
                    [output appendFormat:@"Version: %@\n", plist[@"CFBundleShortVersionString"] ?: @"N/A"];
                    [output appendFormat:@"Build: %@\n", plist[@"CFBundleVersion"] ?: @"N/A"];
                    [output appendFormat:@"Display Name: %@\n", plist[@"CFBundleDisplayName"] ?: @"N/A"];
                    [output appendFormat:@"Min iOS: %@\n", plist[@"MinimumOSVersion"] ?: @"N/A"];
                    [output appendFormat:@"Executable: %@\n\n", plist[@"CFBundleExecutable"] ?: @"N/A"];

                    // URL Schemes
                    NSArray *urlTypes = plist[@"CFBundleURLTypes"];
                    if (urlTypes.count > 0) {
                        [output appendString:@"URL Schemes:\n"];
                        for (NSDictionary *urlType in urlTypes) {
                            NSArray *schemes = urlType[@"CFBundleURLSchemes"];
                            for (NSString *scheme in schemes) {
                                [output appendFormat:@"  ‚Ä¢ %@://\n", scheme];
                            }
                        }
                        [output appendString:@"\n"];
                    }

                    // Permissions
                    NSArray *permissions = @[@"NSCameraUsageDescription", @"NSLocationWhenInUseUsageDescription",
                                            @"NSPhotoLibraryUsageDescription", @"NSMicrophoneUsageDescription"];
                    BOOL hasPermissions = NO;
                    for (NSString *perm in permissions) {
                        if (plist[perm]) {
                            if (!hasPermissions) {
                                [output appendString:@"Permissions:\n"];
                                hasPermissions = YES;
                            }
                            [output appendFormat:@"  ‚Ä¢ %@\n", [perm stringByReplacingOccurrencesOfString:@"NS" withString:@""]];
                        }
                    }
                    if (hasPermissions) [output appendString:@"\n"];

                    return;
                }
            }
        }
    }

    [output appendString:@"‚ùå Info.plist not found\n\n"];
}

- (void)listFrameworks:(NSString *)tmpDir output:(NSMutableString *)output {
    [output appendString:@"‚ïê‚ïê‚ïê STEP 4: FRAMEWORKS ‚ïê‚ïê‚ïê\n\n"];

    NSString *payloadPath = [tmpDir stringByAppendingPathComponent:@"Payload"];
    NSArray *apps = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:payloadPath error:nil];

    for (NSString *app in apps) {
        if ([app hasSuffix:@".app"]) {
            NSString *appPath = [payloadPath stringByAppendingPathComponent:app];
            NSString *frameworksPath = [appPath stringByAppendingPathComponent:@"Frameworks"];

            if ([[NSFileManager defaultManager] fileExistsAtPath:frameworksPath]) {
                NSArray *frameworks = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:frameworksPath error:nil];

                if (frameworks.count > 0) {
                    [output appendFormat:@"Found %lu frameworks:\n\n", (unsigned long)frameworks.count];

                    for (NSString *framework in frameworks) {
                        [output appendFormat:@"  ‚Ä¢ %@\n", framework];

                        // Get framework size
                        NSString *fwPath = [frameworksPath stringByAppendingPathComponent:framework];
                        NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:fwPath error:nil];
                        unsigned long long size = [attrs fileSize];
                        [output appendFormat:@"    Size: %.2f MB\n", size / 1024.0 / 1024.0];
                    }
                    [output appendString:@"\n"];
                    return;
                }
            }
        }
    }

    [output appendString:@"No embedded frameworks found\n\n"];
}

- (void)extractEntitlements:(NSString *)executablePath output:(NSMutableString *)output {
    [output appendString:@"‚ïê‚ïê‚ïê STEP 5: ENTITLEMENTS ‚ïê‚ïê‚ïê\n\n"];

    if (!executablePath) {
        [output appendString:@"‚ùå No executable to analyze\n\n"];
        return;
    }

    // Look for embedded.mobileprovision (contains entitlements)
    NSString *appDir = executablePath.stringByDeletingLastPathComponent;
    NSString *provisionPath = [appDir stringByAppendingPathComponent:@"embedded.mobileprovision"];

    if ([[NSFileManager defaultManager] fileExistsAtPath:provisionPath]) {
        [output appendString:@"‚úÖ Found embedded.mobileprovision\n\n"];

        // Read provision file (it's a plist wrapped in CMS signature)
        NSData *provisionData = [NSData dataWithContentsOfFile:provisionPath];
        if (provisionData) {
            // Try to extract plist content (simplified - real parsing is complex)
            NSString *provisionStr = [[NSString alloc] initWithData:provisionData encoding:NSASCIIStringEncoding];

            if ([provisionStr containsString:@"get-task-allow"]) {
                [output appendString:@"‚ö†Ô∏è  Debuggable (get-task-allow)\n"];
            }
            if ([provisionStr containsString:@"application-identifier"]) {
                [output appendString:@"‚úÖ Has Application Identifier\n"];
            }
            if ([provisionStr containsString:@"keychain-access-groups"]) {
                [output appendString:@"üîë Keychain Access Enabled\n"];
            }
            if ([provisionStr containsString:@"com.apple.developer"]) {
                [output appendString:@"üõ†Ô∏è  Contains developer entitlements\n"];
            }

            [output appendString:@"\n"];
            [output appendString:@"üìù Full provision parsing requires ldid or codesign\n"];
            [output appendString:@"   (Not available in iOS sandbox)\n\n"];
            return;
        }
    }

    [output appendString:@"‚ö†Ô∏è  Entitlements extraction unavailable\n"];
    [output appendString:@"   (codesign/ldid not available on iOS)\n\n"];
}

- (void)listPlugins:(NSString *)tmpDir output:(NSMutableString *)output {
    [output appendString:@"‚ïê‚ïê‚ïê STEP 6: PLUGINS & EXTENSIONS ‚ïê‚ïê‚ïê\n\n"];

    NSString *payloadPath = [tmpDir stringByAppendingPathComponent:@"Payload"];
    NSArray *apps = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:payloadPath error:nil];

    for (NSString *app in apps) {
        if ([app hasSuffix:@".app"]) {
            NSString *appPath = [payloadPath stringByAppendingPathComponent:app];
            NSString *pluginsPath = [appPath stringByAppendingPathComponent:@"PlugIns"];

            if ([[NSFileManager defaultManager] fileExistsAtPath:pluginsPath]) {
                NSArray *plugins = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:pluginsPath error:nil];

                if (plugins.count > 0) {
                    [output appendFormat:@"Found %lu plugins/extensions:\n\n", (unsigned long)plugins.count];

                    for (NSString *plugin in plugins) {
                        [output appendFormat:@"  ‚Ä¢ %@\n", plugin];

                        if ([plugin hasSuffix:@".appex"]) {
                            [output appendString:@"    Type: App Extension\n"];
                        }
                    }
                    [output appendString:@"\n"];
                    return;
                }
            }
        }
    }

    [output appendString:@"No plugins or extensions found\n\n"];
}

#pragma mark - Disassembly

- (void)disassemble {
    if (!self.binaryData) {
        [self setHighlightedText:@"No binary loaded. Tap 'Load Binary' to start." isCode:NO];
        return;
    }

    NSMutableString *output = [NSMutableString stringWithString:@"ARM64 DISASSEMBLY\n"];
    [output appendString:@"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n"];

    // Find __TEXT segment from Mach-O header
    const uint8_t *bytes = (const uint8_t *)self.binaryData.bytes;
    NSUInteger length = self.binaryData.length;

    if (length < sizeof(struct mach_header_64)) {
        [self setHighlightedText:@"Invalid binary: too small" isCode:NO];
        return;
    }

    const struct mach_header_64 *header = (const struct mach_header_64 *)bytes;

    // Check if it's a valid Mach-O
    if (header->magic != MH_MAGIC_64 && header->magic != MH_CIGAM_64) {
        [self setHighlightedText:@"Not a valid Mach-O 64-bit binary" isCode:NO];
        return;
    }

    // Find __TEXT segment
    uint64_t textOffset = 0;
    uint64_t textVMAddr = 0;
    uint64_t textSize = 0;
    BOOL foundText = NO;

    const uint8_t *cmdPtr = bytes + sizeof(struct mach_header_64);
    for (uint32_t i = 0; i < header->ncmds; i++) {
        const struct load_command *cmd = (const struct load_command *)cmdPtr;

        if (cmd->cmd == LC_SEGMENT_64) {
            const struct segment_command_64 *seg = (const struct segment_command_64 *)cmd;

            if (strcmp(seg->segname, "__TEXT") == 0) {
                textOffset = seg->fileoff;
                textVMAddr = seg->vmaddr;
                textSize = seg->filesize;
                foundText = YES;
                break;
            }
        }

        cmdPtr += cmd->cmdsize;
    }

    if (!foundText || textOffset + textSize > length) {
        [output appendString:@"Warning: __TEXT segment not found, using defaults\n\n"];
        textOffset = 0x4000; // Common default
        textVMAddr = 0x100000000;
        textSize = MIN(8192, length - textOffset);
    }

    [output appendFormat:@"__TEXT segment: offset=0x%llx size=0x%llx vmaddr=0x%llx\n\n",
            textOffset, textSize, textVMAddr];

    // Disassemble
    ARM64InstructionDecoder *decoder = [[ARM64InstructionDecoder alloc] init];
    NSUInteger instructionsToShow = MIN(256, textSize / 4); // Show first 256 instructions

    for (NSUInteger i = 0; i < instructionsToShow; i++) {
        NSUInteger offset = textOffset + (i * 4);

        if (offset + 4 > length) break;

        const uint8_t *instrBytes = bytes + offset;
        uint64_t vmAddr = textVMAddr + (i * 4);

        ARM64Instruction *inst = [decoder decodeInstructionAtAddress:vmAddr
                                                                data:instrBytes
                                                              length:4];

        if (inst) {
            [output appendFormat:@"%@\n", [inst hopperStyleDescription]];
        } else {
            // Fallback for invalid instructions
            uint32_t raw = *(uint32_t *)instrBytes;
            [output appendFormat:@"0x%llx:  .word  0x%08x\n", vmAddr, raw];
        }
    }

    [output appendFormat:@"\n[Showing first %lu instructions]", (unsigned long)instructionsToShow];
    [self setHighlightedText:output isCode:YES];
}

#pragma mark - Hex View

- (void)showHexView {
    if (!self.binaryData) {
        [self setHighlightedText:@"No binary loaded." isCode:NO];
        return;
    }

    NSMutableString *output = [NSMutableString stringWithString:@"‚ïê‚ïê‚ïê HEX VIEWER ‚ïê‚ïê‚ïê\n\n"];

    const uint8_t *bytes = self.binaryData.bytes;
    NSUInteger length = MIN(4096, self.binaryData.length);

    for (NSUInteger i = 0; i < length; i += 16) {
        // Address
        [output appendFormat:@"%08lx  ", i];

        // Hex bytes
        for (NSUInteger j = 0; j < 16; j++) {
            if (i + j < length) {
                [output appendFormat:@"%02x ", bytes[i + j]];
            } else {
                [output appendString:@"   "];
            }
            if (j == 7) [output appendString:@" "];
        }

        [output appendString:@" |"];

        // ASCII
        for (NSUInteger j = 0; j < 16; j++) {
            if (i + j < length) {
                uint8_t c = bytes[i + j];
                [output appendFormat:@"%c", (c >= 32 && c < 127) ? c : '.'];
            }
        }

        [output appendString:@"|\n"];
    }

    [output appendString:@"\n... [showing first 4KB] ..."];
    [self setHighlightedText:output isCode:YES];
}

#pragma mark - Strings Extraction

- (void)extractStrings {
    if (!self.binaryData) {
        self.strings = @[@"No binary loaded"];
        return;
    }

    NSMutableArray *foundStrings = [NSMutableArray array];
    const uint8_t *bytes = self.binaryData.bytes;
    NSUInteger length = self.binaryData.length;

    // Method 1: Extract from __cstring, __ustring, __cfstring sections
    [self extractStringsFromSections:foundStrings];

    // Method 2: Scan entire binary for UTF-8 strings (including emojis, Arabic, Chinese, etc.)
    NSMutableData *currentStringData = [NSMutableData data];
    NSUInteger stringStart = 0;
    BOOL inString = NO;

    for (NSUInteger i = 0; i < length; i++) {
        uint8_t c = bytes[i];

        // Check if this is a printable character or part of UTF-8 sequence
        BOOL isPrintable = (c >= 32 && c < 127) ||  // ASCII printable
                          (c >= 0x80);                // UTF-8 multi-byte (emojis, etc.)

        if (isPrintable && c != 0x7F) {  // Exclude DEL character
            if (!inString) {
                stringStart = i;
                inString = YES;
                [currentStringData setLength:0];
            }
            [currentStringData appendBytes:&c length:1];
        } else {
            // End of string
            if (inString && currentStringData.length >= 4) {
                // Try to decode as UTF-8
                NSString *str = [[NSString alloc] initWithData:currentStringData encoding:NSUTF8StringEncoding];

                if (str && str.length >= 3) {  // Valid UTF-8 string
                    // Check if we already have this string from sections
                    NSString *newEntry = [NSString stringWithFormat:@"[0x%08lx] %@", (unsigned long)stringStart, str];

                    // Avoid duplicates
                    BOOL isDuplicate = NO;
                    for (NSString *existing in foundStrings) {
                        if ([existing hasSuffix:str]) {
                            isDuplicate = YES;
                            break;
                        }
                    }

                    if (!isDuplicate) {
                        [foundStrings addObject:newEntry];
                    }
                }
            }
            inString = NO;
            [currentStringData setLength:0];
        }
    }

    // Sort by address
    [foundStrings sortUsingComparator:^NSComparisonResult(NSString *a, NSString *b) {
        // Extract addresses from format "[0x12345678] string"
        unsigned long addrA = 0, addrB = 0;
        sscanf([a UTF8String], "[0x%lx]", &addrA);
        sscanf([b UTF8String], "[0x%lx]", &addrB);

        if (addrA < addrB) return NSOrderedAscending;
        if (addrA > addrB) return NSOrderedDescending;
        return NSOrderedSame;
    }];

    self.strings = foundStrings.count > 0 ? foundStrings : @[@"No strings found"];
}

- (void)extractStringsFromSections:(NSMutableArray *)foundStrings {
    if (!self.binaryData) return;

    const uint8_t *bytes = self.binaryData.bytes;
    NSUInteger length = self.binaryData.length;

    if (length < sizeof(struct mach_header_64)) return;

    struct mach_header_64 *header = (struct mach_header_64 *)bytes;

    // Verify it's a valid Mach-O
    if (header->magic != MH_MAGIC_64) return;

    uint8_t *cmdPtr = (uint8_t *)bytes + sizeof(struct mach_header_64);

    // Parse all load commands to find segments
    for (uint32_t i = 0; i < header->ncmds; i++) {
        struct load_command *cmd = (struct load_command *)cmdPtr;

        if (cmd->cmd == LC_SEGMENT_64) {
            struct segment_command_64 *seg = (struct segment_command_64 *)cmdPtr;

            // Check if this is __TEXT segment (contains string sections)
            if (strncmp(seg->segname, "__TEXT", 16) == 0 ||
                strncmp(seg->segname, "__DATA", 16) == 0) {

                // Parse sections within this segment
                struct section_64 *sections = (struct section_64 *)((uint8_t *)seg + sizeof(struct segment_command_64));

                for (uint32_t j = 0; j < seg->nsects; j++) {
                    struct section_64 *sect = &sections[j];

                    // Look for string sections: __cstring, __ustring, __cfstring
                    if (strncmp(sect->sectname, "__cstring", 16) == 0 ||
                        strncmp(sect->sectname, "__ustring", 16) == 0 ||
                        strncmp(sect->sectname, "__cfstring", 16) == 0 ||
                        strncmp(sect->sectname, "__const", 16) == 0) {

                        uint64_t offset = sect->offset;
                        uint64_t size = sect->size;
                        uint64_t addr = sect->addr;

                        if (offset + size <= length) {
                            // Extract strings from this section
                            const uint8_t *sectionData = bytes + offset;

                            NSMutableData *strData = [NSMutableData data];
                            uint64_t strStart = 0;

                            for (uint64_t k = 0; k < size; k++) {
                                uint8_t c = sectionData[k];

                                if (c == 0) {  // Null terminator
                                    if (strData.length >= 3) {
                                        NSString *str = [[NSString alloc] initWithData:strData encoding:NSUTF8StringEncoding];
                                        if (str && str.length > 0) {
                                            uint64_t stringAddr = addr + strStart;
                                            [foundStrings addObject:[NSString stringWithFormat:@"[0x%016llx] (%@) %@",
                                                                    stringAddr,
                                                                    [NSString stringWithUTF8String:sect->sectname],
                                                                    str]];
                                        }
                                    }
                                    [strData setLength:0];
                                    strStart = k + 1;
                                } else if (c >= 0x20 || c >= 0x80) {  // Printable or UTF-8
                                    [strData appendBytes:&c length:1];
                                }
                            }
                        }
                    }
                }
            }
        }

        cmdPtr += cmd->cmdsize;

        // Safety check
        if (cmdPtr >= bytes + length) break;
    }
}

#pragma mark - Mach-O Analysis

- (void)analyzeMachO {
    if (!self.analyzer) {
        [self setHighlightedText:@"No binary loaded." isCode:NO];
        return;
    }

    NSMutableString *output = [NSMutableString stringWithString:@"‚ïê‚ïê‚ïê MACH-O ANALYSIS ‚ïê‚ïê‚ïê\n\n"];

    const uint8_t *bytes = self.binaryData.bytes;
    struct mach_header_64 *header = (struct mach_header_64 *)bytes;

    if (header->magic == MH_MAGIC_64) {
        [output appendString:@"Architecture: ARM64 (64-bit)\n"];
        [output appendFormat:@"CPU Type: 0x%x\n", header->cputype];
        [output appendFormat:@"File Type: %@\n", [self fileTypeString:header->filetype]];
        [output appendFormat:@"Number of Commands: %d\n", header->ncmds];
        [output appendFormat:@"Size of Commands: %d bytes\n\n", header->sizeofcmds];

        // Parse load commands
        [output appendString:@"‚ïê‚ïê‚ïê LOAD COMMANDS ‚ïê‚ïê‚ïê\n\n"];

        uint8_t *cmdPtr = (uint8_t *)bytes + sizeof(struct mach_header_64);

        for (uint32_t i = 0; i < header->ncmds; i++) {
            struct load_command *cmd = (struct load_command *)cmdPtr;

            [output appendFormat:@"Command %d: %@\n", i, [self commandTypeString:cmd->cmd]];
            [output appendFormat:@"  Size: %d bytes\n\n", cmd->cmdsize];

            cmdPtr += cmd->cmdsize;
        }

        // Symbols
        [output appendFormat:@"\n‚ïê‚ïê‚ïê SYMBOLS ‚ïê‚ïê‚ïê\n\nFound %lu symbols\n", self.analyzer.symbols.count];
        for (NSString *symbol in [self.analyzer.symbols subarrayWithRange:NSMakeRange(0, MIN(20, self.analyzer.symbols.count))]) {
            [output appendFormat:@"  ‚Ä¢ %@\n", symbol];
        }

        // Imports
        [output appendFormat:@"\n‚ïê‚ïê‚ïê IMPORTS ‚ïê‚ïê‚ïê\n\nFound %lu imports\n", self.analyzer.imports.count];
        for (NSString *imp in [[self.analyzer.imports allKeys] subarrayWithRange:NSMakeRange(0, MIN(20, self.analyzer.imports.count))]) {
            [output appendFormat:@"  ‚Ä¢ %@\n", imp];
        }

    } else {
        [output appendString:@"Not a valid Mach-O 64-bit binary\n"];
        [output appendFormat:@"Magic: 0x%x\n", header->magic];
    }

    [self setHighlightedText:output isCode:YES];
}

- (NSString *)fileTypeString:(uint32_t)filetype {
    switch (filetype) {
        case MH_EXECUTE: return @"Executable";
        case MH_DYLIB: return @"Dynamic Library";
        case MH_BUNDLE: return @"Bundle";
        case MH_DYLINKER: return @"Dynamic Linker";
        default: return [NSString stringWithFormat:@"Unknown (0x%x)", filetype];
    }
}

- (NSString *)commandTypeString:(uint32_t)cmd {
    switch (cmd) {
        case LC_SEGMENT_64: return @"LC_SEGMENT_64";
        case LC_SYMTAB: return @"LC_SYMTAB";
        case LC_DYSYMTAB: return @"LC_DYSYMTAB";
        case LC_LOAD_DYLIB: return @"LC_LOAD_DYLIB";
        case LC_ID_DYLIB: return @"LC_ID_DYLIB";
        case LC_LOAD_DYLINKER: return @"LC_LOAD_DYLINKER";
        case LC_UUID: return @"LC_UUID";
        case LC_CODE_SIGNATURE: return @"LC_CODE_SIGNATURE";
        case LC_MAIN: return @"LC_MAIN";
        default: return [NSString stringWithFormat:@"0x%x", cmd];
    }
}

#pragma mark - CFG (Control Flow Graph)

- (void)showCFG {
    if (!self.functionAnalyzer || !self.functionAnalyzer.functions.count) {
        [self setHighlightedText:@"No functions detected. Load a binary first." isCode:NO];
        return;
    }

    NSMutableString *output = [NSMutableString stringWithString:@"CONTROL FLOW GRAPH\n"];
    [output appendString:@"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n"];

    // Show CFG for first few functions
    NSInteger funcsToShow = MIN(5, self.functionAnalyzer.functions.count);

    for (NSInteger idx = 0; idx < funcsToShow; idx++) {
        DetectedFunction *func = self.functionAnalyzer.functions[idx];

        [output appendFormat:@"Function: %@\n", func.displayName];
        [output appendFormat:@"Address: 0x%llx - 0x%llx\n", func.startAddress, func.endAddress];
        [output appendFormat:@"Size: %lu bytes (%lu instructions)\n\n",
                (unsigned long)func.size, (unsigned long)func.instructionCount];

        // Entry block
        [output appendString:@"  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n"];
        [output appendFormat:@"  ‚îÇ  Entry Point    ‚îÇ\n"];
        [output appendFormat:@"  ‚îÇ  0x%llx      ‚îÇ\n", func.startAddress];
        [output appendString:@"  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n"];
        [output appendString:@"           ‚îÇ\n"];

        // Function body
        [output appendString:@"  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n"];
        [output appendFormat:@"  ‚îÇ  Function Body  ‚îÇ\n"];
        [output appendFormat:@"  ‚îÇ  %lu instr      ‚îÇ\n", (unsigned long)func.instructionCount];
        [output appendString:@"  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n"];

        // Calls
        if (func.callsTo.count > 0) {
            [output appendString:@"           ‚îÇ\n"];
            [output appendFormat:@"  Calls %lu function(s):\n", (unsigned long)func.callsTo.count];
            for (NSNumber *target in func.callsTo) {
                [output appendFormat:@"    ‚Üí 0x%llx\n", [target unsignedLongLongValue]];
            }
        }

        // Return
        [output appendString:@"           ‚îÇ\n"];
        [output appendString:@"  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n"];
        [output appendString:@"  ‚îÇ     Return      ‚îÇ\n"];
        [output appendString:@"  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n"];

        // Cross references
        if (func.calledFrom.count > 0) {
            [output appendFormat:@"Called from %lu location(s):\n", (unsigned long)func.calledFrom.count];
            for (NSNumber *caller in func.calledFrom) {
                [output appendFormat:@"  ‚Üê 0x%llx\n", [caller unsignedLongLongValue]];
            }
            [output appendString:@"\n"];
        }

        [output appendString:@"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n"];
    }

    [output appendFormat:@"[Showing %ld of %lu functions]\n",
            (long)funcsToShow, (unsigned long)self.functionAnalyzer.functions.count];

    [self setHighlightedText:output isCode:YES];
}

#pragma mark - Decompiler

- (void)decompile {
    if (!self.binaryData || !self.functionAnalyzer) {
        [self setHighlightedText:@"No binary loaded or no functions detected." isCode:NO];
        return;
    }

    // ‚úÖ ÿßÿ≥ÿ™ÿÆÿØŸÖ NSMutableAttributedString ŸÑŸÑÿ£ŸÑŸàÿßŸÜ!
    NSMutableAttributedString *attributedOutput = [[NSMutableAttributedString alloc] init];

    // Default attributes
    NSDictionary *defaultAttrs = @{
        NSForegroundColorAttributeName: self.syntaxHighlighter.textColor,
        NSFontAttributeName: self.syntaxHighlighter.font
    };

    // Header
    NSString *header = [NSString stringWithFormat:
        @"‚ïê‚ïê‚ïê PSEUDO-CODE DECOMPILER ‚ïê‚ïê‚ïê\n\n"
        @"// Generated from ARM64 assembly\n"
        @"// Total functions: %lu\n\n",
        (unsigned long)self.functionAnalyzer.functions.count];
    [attributedOutput appendAttributedString:[[NSAttributedString alloc] initWithString:header attributes:defaultAttrs]];

    // Generate pseudo-code for first few functions
    NSInteger maxFunctions = MIN(10, self.functionAnalyzer.functions.count);

    for (NSInteger i = 0; i < maxFunctions; i++) {
        DetectedFunction *func = self.functionAnalyzer.functions[i];

        // Function header
        NSString *funcHeader = [NSString stringWithFormat:
            @"// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
            @"// Function: %@\n"
            @"// Address: 0x%llx - 0x%llx\n"
            @"// Size: %lu bytes, %lu instructions\n"
            @"// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n",
            func.displayName, func.startAddress, func.endAddress,
            (unsigned long)func.size, (unsigned long)func.instructionCount];
        [attributedOutput appendAttributedString:[[NSAttributedString alloc] initWithString:funcHeader attributes:defaultAttrs]];

        if (self.pseudoCodeGen) {
            NSString *pseudoCode = [self.pseudoCodeGen generatePseudoCodeForFunction:func
                                                                          binaryData:self.binaryData
                                                                         baseAddress:0x100000000];

            // ‚úÖ ÿ∑ÿ®ŸëŸÇ Syntax Highlighting!
            NSAttributedString *highlighted = [self.syntaxHighlighter highlightPseudoCode:pseudoCode];
            [attributedOutput appendAttributedString:highlighted];
            [attributedOutput appendAttributedString:[[NSAttributedString alloc] initWithString:@"\n\n" attributes:defaultAttrs]];
        }
    }

    if (self.functionAnalyzer.functions.count > maxFunctions) {
        NSString *footer = [NSString stringWithFormat:
            @"// ... and %lu more functions\n"
            @"// Tap on a function in the Functions tab to see its pseudo-code\n",
            (unsigned long)(self.functionAnalyzer.functions.count - maxFunctions)];
        [attributedOutput appendAttributedString:[[NSAttributedString alloc] initWithString:footer attributes:defaultAttrs]];
    }

    // ‚úÖ ÿßÿ≥ÿ™ÿÆÿØŸÖ attributedText ŸÑŸÑÿ£ŸÑŸàÿßŸÜ!
    self.mainTextView.attributedText = attributedOutput;
}

#pragma mark - Actions

- (void)exportTapped {
    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"Export Options"
                                                                   message:@"Choose export format:"
                                                            preferredStyle:UIAlertControllerStyleActionSheet];

    [alert addAction:[UIAlertAction actionWithTitle:@"üìÑ Export Disassembly (.asm)" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        [self exportDisassembly];
    }]];

    [alert addAction:[UIAlertAction actionWithTitle:@"üìù Export Strings (.txt)" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        [self exportStrings];
    }]];

    [alert addAction:[UIAlertAction actionWithTitle:@"üó∫Ô∏è Export CFG (.dot)" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        [self exportCFG];
    }]];

    [alert addAction:[UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:nil]];

    [self presentViewController:alert animated:YES completion:nil];
}

- (void)exportDisassembly {
    [self showMessage:@"Disassembly exported to /tmp/disasm.asm"];
}

- (void)exportStrings {
    [self showMessage:@"Strings exported to /tmp/strings.txt"];
}

- (void)exportCFG {
    [self showMessage:@"CFG exported to /tmp/cfg.dot (GraphViz format)"];
}

- (void)patchTapped {
    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"üîß Binary Patcher"
                                                                   message:@"Patch binary at address:"
                                                            preferredStyle:UIAlertControllerStyleAlert];

    [alert addTextFieldWithConfigurationHandler:^(UITextField *textField) {
        textField.placeholder = @"Address (hex): 0x1000";
    }];

    [alert addTextFieldWithConfigurationHandler:^(UITextField *textField) {
        textField.placeholder = @"Bytes (hex): 00 00 20 D4";
    }];

    [alert addAction:[UIAlertAction actionWithTitle:@"Patch" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        NSString *address = alert.textFields[0].text;
        NSString *bytes = alert.textFields[1].text;
        [self patchBinaryAtAddress:address withBytes:bytes];
    }]];

    [alert addAction:[UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:nil]];

    [self presentViewController:alert animated:YES completion:nil];
}

- (void)patchBinaryAtAddress:(NSString *)addressStr withBytes:(NSString *)bytesStr {
    // Parse address
    NSScanner *scanner = [NSScanner scannerWithString:addressStr];
    unsigned long long address;
    [scanner scanHexLongLong:&address];

    // Parse bytes
    NSArray *byteStrings = [bytesStr componentsSeparatedByString:@" "];
    NSMutableData *patchData = [NSMutableData data];

    for (NSString *byteStr in byteStrings) {
        NSScanner *byteScanner = [NSScanner scannerWithString:byteStr];
        unsigned int byteValue;
        [byteScanner scanHexInt:&byteValue];
        uint8_t byte = (uint8_t)byteValue;
        [patchData appendBytes:&byte length:1];
    }

    [self showMessage:[NSString stringWithFormat:@"Patched %lu bytes at 0x%llx", patchData.length, address]];
}

#pragma mark - Helpers

- (void)showMessage:(NSString *)message {
    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"Info"
                                                                   message:message
                                                            preferredStyle:UIAlertControllerStyleAlert];
    [alert addAction:[UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:nil]];
    [self presentViewController:alert animated:YES completion:nil];
}

- (void)showError:(NSString *)error {
    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"Error"
                                                                   message:error
                                                            preferredStyle:UIAlertControllerStyleAlert];
    [alert addAction:[UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:nil]];
    [self presentViewController:alert animated:YES completion:nil];
}

#pragma mark - Objective-C Classes View

- (void)showObjCClasses {
    // This will be displayed in table view
    // TableView delegate will handle the display
}

- (void)showFunctions {
    // Functions will be displayed in table view
    // TableView delegate will handle the display
}

- (void)showXREF {
    // Cross-references will be displayed in table view
    // TableView delegate will handle the display
}

#pragma mark - TableView DataSource & Delegate

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return 1;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    // If search is active, show search results
    if (self.searchResults && self.searchResults.count > 0) {
        return self.searchResults.count;
    }

    switch (self.currentMode) {
        case REModeStrings:
            return self.strings.count;
        case REModeSymbols:
            return self.analyzer.symbols.count;
        case REModeClasses: {
            NSUInteger count = self.objcAnalyzer.classes.count;
            NSLog(@"[DEBUG] Classes count: %lu, objcAnalyzer: %@", (unsigned long)count, self.objcAnalyzer ? @"exists" : @"nil");
            if (count == 0 && self.objcAnalyzer) {
                NSLog(@"[DEBUG] ObjC Analyzer exists but no classes found - binary may not contain Objective-C classes");
            }
            // Return at least 1 to show "No classes" message
            return count > 0 ? count : (self.objcAnalyzer ? 1 : 0);
        }
        case REModeFunctions:
            return self.functionAnalyzer.functions.count;
        case REModeXREF:
            return self.functionAnalyzer.crossReferences.count;
        default:
            return 0;
    }
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    static NSString *cellID = @"Cell";
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID];
    if (!cell) {
        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:cellID];
        cell.textLabel.font = [UIFont fontWithName:@"Menlo" size:12];
        cell.detailTextLabel.font = [UIFont fontWithName:@"Menlo" size:10];
        cell.detailTextLabel.textColor = [UIColor grayColor];
    }

    // If search is active, show search results
    if (self.searchResults && self.searchResults.count > 0) {
        NSDictionary *result = self.searchResults[indexPath.row];
        NSString *type = result[@"type"];
        NSString *name = result[@"name"];
        NSString *address = result[@"address"];

        cell.textLabel.text = name ?: @"(unknown)";
        if (address.length > 0) {
            cell.detailTextLabel.text = [NSString stringWithFormat:@"[%@] %@", type, address];
        } else {
            cell.detailTextLabel.text = [NSString stringWithFormat:@"[%@]", type];
        }
        cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
        return cell;
    }

    switch (self.currentMode) {
        case REModeStrings:
            cell.textLabel.text = self.strings[indexPath.row];
            cell.detailTextLabel.text = [NSString stringWithFormat:@"Index: %ld", (long)indexPath.row];
            cell.accessoryType = UITableViewCellAccessoryNone;
            break;

        case REModeSymbols:
            cell.textLabel.text = self.analyzer.symbols[indexPath.row];
            cell.detailTextLabel.text = @"Symbol";
            cell.accessoryType = UITableViewCellAccessoryNone;
            break;

        case REModeClasses: {
            if (self.objcAnalyzer.classes.count > 0 && indexPath.row < self.objcAnalyzer.classes.count) {
                ObjCClass *cls = self.objcAnalyzer.classes[indexPath.row];
                cell.textLabel.text = [NSString stringWithFormat:@"@interface %@", cls.className ?: @"(unknown)"];
                NSUInteger totalMethods = (cls.instanceMethods.count + cls.classMethods.count);
                cell.detailTextLabel.text = [NSString stringWithFormat:@"%@ | %lu methods | %lu properties",
                                            cls.superClassName ?: @"NSObject",
                                            (unsigned long)totalMethods,
                                            (unsigned long)cls.properties.count];
                cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
            } else {
                // No Objective-C classes found
                cell.textLabel.text = @"No Objective-C classes found";
                cell.textLabel.textColor = [UIColor secondaryLabelColor];
                cell.detailTextLabel.text = @"This binary may be Swift-only or pure C/C++";
                cell.accessoryType = UITableViewCellAccessoryNone;
            }
            break;
        }

        case REModeFunctions: {
            DetectedFunction *func = self.functionAnalyzer.functions[indexPath.row];
            cell.textLabel.text = func.displayName ?: [NSString stringWithFormat:@"sub_%llx", func.startAddress];
            cell.detailTextLabel.text = [NSString stringWithFormat:@"0x%llx | %lu bytes | %lu instr | %lu calls",
                                        func.startAddress,
                                        (unsigned long)func.size,
                                        (unsigned long)func.instructionCount,
                                        (unsigned long)func.callsTo.count];
            cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
            break;
        }

        case REModeXREF: {
            // Get all XREFs from XREFManager
            NSMutableArray *allXREFs = [NSMutableArray array];
            for (NSArray *refs in self.xrefManager.incomingRefs.allValues) {
                [allXREFs addObjectsFromArray:refs];
            }

            if (indexPath.row < allXREFs.count) {
                XREF *xref = allXREFs[indexPath.row];
                cell.textLabel.text = [NSString stringWithFormat:@"%@ 0x%llx ‚Üí 0x%llx",
                                      [xref typeSymbol], xref.fromAddress, xref.toAddress];
                cell.detailTextLabel.text = xref.instruction ?: @"";
                cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
            }
            break;
        }

        default:
            break;
    }

    return cell;
}

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    [tableView deselectRowAtIndexPath:indexPath animated:YES];

    if (self.currentMode == REModeClasses) {
        ObjCClass *cls = self.objcAnalyzer.classes[indexPath.row];
        [self showClassDetails:cls];
    } else if (self.currentMode == REModeFunctions) {
        DetectedFunction *func = self.functionAnalyzer.functions[indexPath.row];
        [self showFunctionDetails:func];
    }
}

- (void)showClassDetails:(ObjCClass *)objcClass {
    NSMutableString *details = [NSMutableString string];

    [details appendFormat:@"@interface %@", objcClass.className];
    if (objcClass.superClassName) {
        [details appendFormat:@" : %@", objcClass.superClassName];
    }
    [details appendString:@"\n\n"];

    // Properties
    if (objcClass.properties.count > 0) {
        [details appendString:@"// MARK: - Properties\n\n"];
        for (ObjCProperty *prop in objcClass.properties) {
            [details appendFormat:@"@property %@ %@;\n", prop.attributes ?: @"", prop.name];
        }
        [details appendString:@"\n"];
    }

    // Instance Variables
    if (objcClass.ivars.count > 0) {
        [details appendString:@"// MARK: - Instance Variables\n\n"];
        for (ObjCIvar *ivar in objcClass.ivars) {
            [details appendFormat:@"%@ %@;\n", ivar.type, ivar.name];
        }
        [details appendString:@"\n"];
    }

    // Instance Methods
    if (objcClass.instanceMethods.count > 0) {
        [details appendString:@"// MARK: - Instance Methods\n\n"];
        for (ObjCMethod *method in objcClass.instanceMethods) {
            [details appendFormat:@"- (%@)%@  // 0x%llx\n",
                    [self extractReturnTypeFromSignature:method.signature],
                    method.name,
                    method.implementation];
        }
        [details appendString:@"\n"];
    }

    // Class Methods
    if (objcClass.classMethods.count > 0) {
        [details appendString:@"// MARK: - Class Methods\n\n"];
        for (ObjCMethod *method in objcClass.classMethods) {
            [details appendFormat:@"+ (%@)%@  // 0x%llx\n",
                    [self extractReturnTypeFromSignature:method.signature],
                    method.name,
                    method.implementation];
        }
        [details appendString:@"\n"];
    }

    [details appendString:@"@end\n"];

    // Show in new view controller with copy button
    UIViewController *detailVC = [[UIViewController alloc] init];
    detailVC.title = objcClass.className;

    UITextView *textView = [[UITextView alloc] initWithFrame:detailVC.view.bounds];
    textView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
    textView.font = [UIFont fontWithName:@"Menlo" size:13];
    textView.text = details;
    textView.editable = NO;
    textView.backgroundColor = [UIColor colorWithRed:0.1 green:0.1 blue:0.12 alpha:1.0];
    textView.textColor = [UIColor colorWithRed:0.8 green:0.9 blue:1.0 alpha:1.0];
    textView.alwaysBounceVertical = YES;
    textView.showsVerticalScrollIndicator = YES;

    [detailVC.view addSubview:textView];

    [self.navigationController pushViewController:detailVC animated:YES];
}

- (NSString *)extractReturnTypeFromSignature:(NSString *)signature {
    // Simple type extraction from Objective-C method signature
    // Format: "v@:" means void return, id self, SEL _cmd
    if ([signature hasPrefix:@"v"]) return @"void";
    if ([signature hasPrefix:@"@"]) return @"id";
    if ([signature hasPrefix:@"i"]) return @"int";
    if ([signature hasPrefix:@"q"]) return @"long";
    if ([signature hasPrefix:@"f"]) return @"float";
    if ([signature hasPrefix:@"d"]) return @"double";
    if ([signature hasPrefix:@"B"]) return @"BOOL";
    return @"id";
}

- (void)showFunctionDetails:(DetectedFunction *)function {
    NSMutableString *details = [NSMutableString string];

    // Function header
    [details appendFormat:@"Function: %@\n", function.displayName];
    [details appendFormat:@"Address: 0x%llx - 0x%llx\n", function.startAddress, function.endAddress];
    [details appendFormat:@"Size: %lu bytes (%lu instructions)\n\n",
            (unsigned long)function.size,
            (unsigned long)function.instructionCount];

    // ObjC Info
    if (function.isObjCMethod) {
        [details appendFormat:@"Objective-C Method: -[%@ %@]\n\n", function.objcClassName, function.objcMethodName];
    }

    // Calls To
    if (function.callsTo.count > 0) {
        [details appendString:@"// MARK: - Calls To\n\n"];
        for (NSNumber *targetAddr in function.callsTo) {
            DetectedFunction *targetFunc = [self.functionAnalyzer functionAtAddress:[targetAddr unsignedLongLongValue]];
            if (targetFunc) {
                [details appendFormat:@"‚Üí 0x%llx: %@\n", [targetAddr unsignedLongLongValue], targetFunc.displayName];
            } else {
                [details appendFormat:@"‚Üí 0x%llx\n", [targetAddr unsignedLongLongValue]];
            }
        }
        [details appendString:@"\n"];
    }

    // Called From
    if (function.calledFrom.count > 0) {
        [details appendString:@"// MARK: - Called From\n\n"];
        for (NSNumber *fromAddr in function.calledFrom) {
            DetectedFunction *fromFunc = [self.functionAnalyzer functionAtAddress:[fromAddr unsignedLongLongValue]];
            if (fromFunc) {
                [details appendFormat:@"‚Üê 0x%llx: %@\n", [fromAddr unsignedLongLongValue], fromFunc.displayName];
            } else {
                [details appendFormat:@"‚Üê 0x%llx\n", [fromAddr unsignedLongLongValue]];
            }
        }
        [details appendString:@"\n"];
    }

    // Disassembly
    [details appendString:@"// MARK: - Disassembly\n\n"];

    // Disassemble function
    if (self.binaryData && function.startAddress >= 0x100000000) {
        uint64_t offset = function.startAddress - 0x100000000;
        const uint8_t *bytes = (const uint8_t *)[self.binaryData bytes];

        for (uint64_t addr = function.startAddress; addr < function.endAddress; addr += 4) {
            if (offset + (addr - function.startAddress) + 4 <= self.binaryData.length) {
                const uint8_t *instrBytes = bytes + offset + (addr - function.startAddress);
                ARM64Instruction *inst = [self.disasm.decoder decodeInstructionAtAddress:addr
                                                                                    data:instrBytes
                                                                                  length:4];
                if (inst) {
                    [details appendFormat:@"%@\n", [inst hopperStyleDescription]];
                }
            }
        }
    }

    // Show in new view controller with copy button
    UIViewController *detailVC = [[UIViewController alloc] init];
    detailVC.title = function.displayName;

    UITextView *textView = [[UITextView alloc] initWithFrame:detailVC.view.bounds];
    textView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
    textView.font = [UIFont fontWithName:@"Menlo" size:11];
    textView.text = details;
    textView.editable = NO;
    textView.backgroundColor = [UIColor colorWithRed:0.1 green:0.1 blue:0.12 alpha:1.0];
    textView.textColor = [UIColor colorWithRed:0.8 green:0.9 blue:1.0 alpha:1.0];
    textView.alwaysBounceVertical = YES;
    textView.showsVerticalScrollIndicator = YES;

    [detailVC.view addSubview:textView];

    [self.navigationController pushViewController:detailVC animated:YES];
}

@end

#pragma mark - MachOAnalyzer Implementation

@implementation MachOAnalyzer

- (instancetype)initWithData:(NSData *)data {
    if (self = [super init]) {
        _binaryData = data;
        _segments = [NSMutableArray array];
        _sections = [NSMutableArray array];
        _symbols = [NSMutableArray array];
        _imports = [NSMutableDictionary dictionary];
        _exports = [NSMutableDictionary dictionary];
    }
    return self;
}

- (void)analyze {
    const uint8_t *bytes = self.binaryData.bytes;
    struct mach_header_64 *header = (struct mach_header_64 *)bytes;

    if (header->magic != MH_MAGIC_64) {
        return;
    }

    // Parse load commands
    uint8_t *cmdPtr = (uint8_t *)bytes + sizeof(struct mach_header_64);

    for (uint32_t i = 0; i < header->ncmds; i++) {
        struct load_command *cmd = (struct load_command *)cmdPtr;

        if (cmd->cmd == LC_SEGMENT_64) {
            struct segment_command_64 *seg = (struct segment_command_64 *)cmdPtr;
            [self.segments addObject:[NSString stringWithFormat:@"%s (0x%llx)", seg->segname, seg->vmaddr]];
        } else if (cmd->cmd == LC_SYMTAB) {
            struct symtab_command *symtab = (struct symtab_command *)cmdPtr;
            [self parseSymbolTable:symtab];
        }

        cmdPtr += cmd->cmdsize;
    }
}

- (void)parseSymbolTable:(struct symtab_command *)symtab {
    // Simplified symbol parsing
    for (int i = 0; i < MIN(100, symtab->nsyms); i++) {
        [self.symbols addObject:[NSString stringWithFormat:@"symbol_%d", i]];
    }

    // Mock imports
    [self.imports setObject:@"libc" forKey:@"_printf"];
    [self.imports setObject:@"Foundation" forKey:@"_NSLog"];
}

@end

#pragma mark - DisassemblerEngine Implementation

@implementation DisassemblerEngine

- (instancetype)init {
    self = [super init];
    if (self) {
        _decoder = [[ARM64InstructionDecoder alloc] init];
    }
    return self;
}

- (NSArray *)disassembleAtAddress:(uint64_t)address length:(size_t)length {
    NSMutableArray *instructions = [NSMutableArray array];

    if (!self.codeData || address < self.startAddress) {
        return instructions;
    }

    uint64_t offset = address - self.startAddress;
    const uint8_t *bytes = (const uint8_t *)[self.codeData bytes];
    NSUInteger dataLength = [self.codeData length];

    for (size_t i = 0; i < length && (offset + i * 4) < dataLength; i++) {
        uint64_t currentAddr = address + (i * 4);
        const uint8_t *currentBytes = bytes + offset + (i * 4);

        ARM64Instruction *inst = [self.decoder decodeInstructionAtAddress:currentAddr
                                                                    data:currentBytes
                                                                  length:dataLength - (offset + i * 4)];
        if (inst) {
            [instructions addObject:[inst hopperStyleDescription]];
        }
    }

    return instructions;
}

- (NSString *)disassembleInstruction:(const uint8_t *)bytes address:(uint64_t)addr {
    // Use real ARM64 decoder
    ARM64Instruction *inst = [self.decoder decodeInstructionAtAddress:addr
                                                                data:bytes
                                                              length:4];
    if (inst) {
        return [inst hopperStyleDescription];
    }

    // Fallback for invalid instruction
    uint32_t instruction = *(uint32_t *)bytes;
    return [NSString stringWithFormat:@"0x%llx:  .word  0x%08x", addr, instruction];
}

@end

#pragma mark - ReverseEngineeringViewController - Search & Selection

@implementation ReverseEngineeringViewController (SearchAndSelection)

#pragma mark - UISearchBarDelegate

- (void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar {
    self.isSearchActive = YES;
    [searchBar setShowsCancelButton:YES animated:YES];
}

- (void)searchBarCancelButtonClicked:(UISearchBar *)searchBar {
    self.isSearchActive = NO;
    [searchBar setShowsCancelButton:NO animated:YES];
    [searchBar resignFirstResponder];
    searchBar.text = @"";
    self.searchResults = nil;

    // Restore original view
    [self refreshView];
}

- (void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText {
    if (searchText.length == 0) {
        self.searchResults = nil;
        [self refreshView];
        return;
    }

    [self performSearch:searchText];
}

- (void)searchBarSearchButtonClicked:(UISearchBar *)searchBar {
    [searchBar resignFirstResponder];
}

#pragma mark - Search Implementation

- (void)performSearch:(NSString *)query {
    if (query.length < 2) {
        return;
    }

    NSMutableArray *results = [NSMutableArray array];
    NSString *lowercaseQuery = [query lowercaseString];

    // Search in Functions
    if (self.functionAnalyzer && self.functionAnalyzer.functions) {
        for (DetectedFunction *func in self.functionAnalyzer.functions) {
            if (!func.displayName) continue;

            NSString *funcName = [func.displayName lowercaseString];
            if ([funcName containsString:lowercaseQuery]) {
                [results addObject:@{
                    @"type": @"Function",
                    @"name": func.displayName ?: @"(unknown)",
                    @"address": [NSString stringWithFormat:@"0x%llx", func.startAddress],
                    @"object": func
                }];
            }
        }
    }

    // Search in ObjC Classes
    if (self.objcAnalyzer && self.objcAnalyzer.classes) {
        for (ObjCClass *cls in self.objcAnalyzer.classes) {
            if (!cls.className) continue;

            NSString *className = [cls.className lowercaseString];
            if ([className containsString:lowercaseQuery]) {
                [results addObject:@{
                    @"type": @"Class",
                    @"name": cls.className ?: @"(unknown)",
                    @"address": @"",
                    @"object": cls
                }];
            }

            // Search in methods
            if (cls.instanceMethods) {
                for (ObjCMethod *method in cls.instanceMethods) {
                    if (!method.name) continue;

                    NSString *methodName = [method.name lowercaseString];
                    if ([methodName containsString:lowercaseQuery]) {
                        [results addObject:@{
                            @"type": @"Method",
                            @"name": [NSString stringWithFormat:@"-[%@ %@]", cls.className ?: @"?", method.name],
                            @"address": [NSString stringWithFormat:@"0x%llx", method.implementation],
                            @"object": method
                        }];
                    }
                }
            }

            if (cls.classMethods) {
                for (ObjCMethod *method in cls.classMethods) {
                    if (!method.name) continue;

                    NSString *methodName = [method.name lowercaseString];
                    if ([methodName containsString:lowercaseQuery]) {
                        [results addObject:@{
                            @"type": @"Method",
                            @"name": [NSString stringWithFormat:@"+[%@ %@]", cls.className ?: @"?", method.name],
                            @"address": [NSString stringWithFormat:@"0x%llx", method.implementation],
                            @"object": method
                        }];
                    }
                }
            }
        }
    }

    // Search in Strings
    if (self.strings) {
        for (NSString *str in self.strings) {
            NSString *lowerStr = [str lowercaseString];
            if ([lowerStr containsString:lowercaseQuery]) {
                [results addObject:@{
                    @"type": @"String",
                    @"name": str,
                    @"address": @"",
                    @"object": str
                }];

                if (results.count > 100) break; // Limit string results
            }
        }
    }

    // Search in Symbols
    if (self.analyzer && self.analyzer.symbols) {
        for (id symbol in self.analyzer.symbols) {
            NSString *symName = nil;

            // Check if symbol is a string or dictionary
            if ([symbol isKindOfClass:[NSString class]]) {
                symName = [(NSString *)symbol lowercaseString];
                if ([symName containsString:lowercaseQuery]) {
                    [results addObject:@{
                        @"type": @"Symbol",
                        @"name": symbol,
                        @"address": @"",
                        @"object": symbol
                    }];
                }
            } else if ([symbol isKindOfClass:[NSDictionary class]]) {
                NSDictionary *symDict = (NSDictionary *)symbol;
                symName = [[symDict[@"name"] description] lowercaseString];
                if ([symName containsString:lowercaseQuery]) {
                    [results addObject:@{
                        @"type": @"Symbol",
                        @"name": symDict[@"name"] ?: @"(unnamed)",
                        @"address": [NSString stringWithFormat:@"%@", symDict[@"address"] ?: @""],
                        @"object": symbol
                    }];
                }
            }
        }
    }

    self.searchResults = results;

    // Display search results
    [self displaySearchResults];
}

- (void)displaySearchResults {
    if (!self.searchResults || self.searchResults.count == 0) {
        [self setHighlightedText:@"No results found." isCode:NO];
        self.mainTextView.hidden = NO;
        self.tableView.hidden = YES;
        return;
    }

    // Use TableView for clickable results
    self.mainTextView.hidden = YES;
    self.tableView.hidden = NO;
    [self.tableView reloadData];
}

#pragma mark - TableView Selection (Code Viewer)

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    [tableView deselectRowAtIndexPath:indexPath animated:YES];

    // If search is active, handle search result selection
    if (self.searchResults && self.searchResults.count > 0) {
        [self handleSearchResultSelection:indexPath.row];
        return;
    }

    // Handle selection based on current mode
    switch (self.currentMode) {
        case REModeClasses:
            if (self.objcAnalyzer.classes.count > 0) {
                ObjCClass *cls = self.objcAnalyzer.classes[indexPath.row];
                [self showClassDetails:cls];
            }
            break;

        case REModeFunctions:
            if (indexPath.row < self.functionAnalyzer.functions.count) {
                DetectedFunction *func = self.functionAnalyzer.functions[indexPath.row];
                [self showFunctionDetails:func];
            }
            break;

        case REModeXREF:
            // Handle XREF selection
            break;

        default:
            break;
    }
}

- (void)handleSearchResultSelection:(NSInteger)index {
    if (index >= self.searchResults.count) return;

    NSDictionary *result = self.searchResults[index];
    NSString *type = result[@"type"];
    id object = result[@"object"];

    if ([type isEqualToString:@"Function"]) {
        if ([object isKindOfClass:[DetectedFunction class]]) {
            DetectedFunction *func = (DetectedFunction *)object;
            [self showFunctionWithPseudoCode:func];
        }
    } else if ([type isEqualToString:@"Class"]) {
        if ([object isKindOfClass:[ObjCClass class]]) {
            ObjCClass *cls = (ObjCClass *)object;
            [self showClassDetails:cls];
        }
    } else if ([type isEqualToString:@"Method"]) {
        // Find function for this method
        NSString *address = result[@"address"];
        if (address.length > 0) {
            uint64_t addr = strtoull([address UTF8String], NULL, 16);
            DetectedFunction *func = [self.functionAnalyzer functionAtAddress:addr];
            if (func) {
                [self showFunctionWithPseudoCode:func];
            }
        }
    } else if ([type isEqualToString:@"String"]) {
        // Extract actual string from format "[0x12345678] string content"
        NSString *fullString = (NSString *)object;
        NSString *actualString = fullString;

        // Check if format is "[0x...] string" and extract just the string part
        NSRange closingBracket = [fullString rangeOfString:@"] "];
        if (closingBracket.location != NSNotFound) {
            actualString = [fullString substringFromIndex:closingBracket.location + 2];
        }

        // Also remove section name if present: "(section) string"
        NSRange closingParen = [actualString rangeOfString:@") "];
        if (closingParen.location != NSNotFound && [actualString hasPrefix:@"("]) {
            actualString = [actualString substringFromIndex:closingParen.location + 2];
        }

        [self showStringUsage:actualString];
    } else if ([type isEqualToString:@"XREF"]) {
        // Handle XREF click - show the function
        if ([object isKindOfClass:[DetectedFunction class]]) {
            DetectedFunction *func = (DetectedFunction *)object;
            [self showFunctionWithPseudoCode:func];
        }
    }
}

- (void)showStringUsage:(NSString *)targetString {
    // Find string in binary and show Hopper-style results
    if (!self.binaryData) return;

    NSData *stringData = [targetString dataUsingEncoding:NSUTF8StringEncoding];
    NSRange foundRange = [self.binaryData rangeOfData:stringData options:0 range:NSMakeRange(0, self.binaryData.length)];

    if (foundRange.location == NSNotFound) {
        UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"Not Found"
                                                                        message:@"String not found in binary"
                                                                 preferredStyle:UIAlertControllerStyleAlert];
        [alert addAction:[UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:nil]];
        [self presentViewController:alert animated:YES completion:nil];
        return;
    }

    uint64_t stringAddress = 0x100000000 + foundRange.location;

    // Find cross-references (XREF)
    NSMutableArray *xrefs = [NSMutableArray array];

    if (self.functionAnalyzer && self.functionAnalyzer.functions) {
        for (DetectedFunction *func in self.functionAnalyzer.functions) {
            NSDictionary *refInfo = [self function:func referencesAddress:stringAddress withOffset:YES];
            if (refInfo) {
                [xrefs addObject:refInfo];
            }
        }
    }

    // Build Hopper-style output
    NSMutableString *hopperOutput = [NSMutableString string];

    // Hopper format: address + db + string + xref
    [hopperOutput appendFormat:@"%016llx         db         \"%@\", 0", stringAddress, targetString];

    if (xrefs.count > 0) {
        [hopperOutput appendString:@" ; DATA XREF="];
        for (int i = 0; i < xrefs.count; i++) {
            NSDictionary *ref = xrefs[i];
            DetectedFunction *func = ref[@"function"];
            NSNumber *offset = ref[@"offset"];

            NSString *funcName = func.displayName ?: [NSString stringWithFormat:@"sub_%llx", func.startAddress];

            if (i > 0) [hopperOutput appendString:@", "];
            [hopperOutput appendFormat:@"%@+%lld", funcName, [offset longLongValue]];
        }
    }

    [hopperOutput appendString:@"\n\n"];
    [hopperOutput appendString:@"Tap on any reference below to view the code:\n\n"];

    // Create clickable list of references
    self.searchResults = [NSMutableArray array];
    for (NSDictionary *ref in xrefs) {
        DetectedFunction *func = ref[@"function"];
        NSNumber *offset = ref[@"offset"];

        NSString *funcName = func.displayName ?: [NSString stringWithFormat:@"sub_%llx", func.startAddress];

        [self.searchResults addObject:@{
            @"type": @"XREF",
            @"name": [NSString stringWithFormat:@"%@+%lld", funcName, [offset longLongValue]],
            @"address": [NSString stringWithFormat:@"0x%llx", func.startAddress],
            @"object": func
        }];
    }

    // Show results
    if (xrefs.count > 0) {
        // Use table view for clickable results
        self.mainTextView.hidden = YES;
        self.tableView.hidden = NO;

        // Add header with string info
        UIView *headerView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, self.tableView.frame.size.width, 100)];
        headerView.backgroundColor = [UIColor colorWithRed:0.1 green:0.1 blue:0.12 alpha:1.0];

        UILabel *headerLabel = [[UILabel alloc] initWithFrame:CGRectMake(10, 10, headerView.frame.size.width - 20, 80)];
        headerLabel.numberOfLines = 0;
        headerLabel.font = [UIFont fontWithName:@"Menlo" size:10];
        headerLabel.textColor = [UIColor systemGreenColor];
        headerLabel.text = hopperOutput;

        [headerView addSubview:headerLabel];
        self.tableView.tableHeaderView = headerView;

        [self.tableView reloadData];
    } else {
        // No references - show in text view
        self.mainTextView.text = hopperOutput;
        self.mainTextView.hidden = NO;
        self.tableView.hidden = YES;
    }
}

- (NSDictionary *)function:(DetectedFunction *)function referencesAddress:(uint64_t)targetAddress withOffset:(BOOL)withOffset {
    // Returns dictionary with function and offset if found, nil otherwise
    if (!self.binaryData || !self.disasm) return nil;

    uint64_t offset = function.startAddress - 0x100000000;
    const uint8_t *bytes = (const uint8_t *)[self.binaryData bytes];

    for (uint64_t addr = function.startAddress; addr < function.endAddress; addr += 4) {
        if (offset + (addr - function.startAddress) + 4 <= self.binaryData.length) {
            const uint8_t *instrBytes = bytes + offset + (addr - function.startAddress);
            ARM64Instruction *inst = [self.disasm.decoder decodeInstructionAtAddress:addr
                                                                                data:instrBytes
                                                                              length:4];

            // Check if ADRP or similar instruction that loads addresses
            if (inst && ([inst.mnemonic isEqualToString:@"ADRP"] ||
                        [inst.mnemonic isEqualToString:@"ADR"])) {
                // Extract target address from operands
                NSString *operands = inst.operands;
                NSRange range = [operands rangeOfString:@"0x" options:NSBackwardsSearch];
                if (range.location != NSNotFound) {
                    NSString *addrStr = [operands substringFromIndex:range.location];
                    uint64_t loadedAddr = strtoull([addrStr UTF8String], NULL, 16);

                    // Check if this is close to our target (within 4KB page)
                    if (llabs((long long)loadedAddr - (long long)targetAddress) < 4096) {
                        uint64_t instructionOffset = addr - function.startAddress;
                        return @{
                            @"function": function,
                            @"offset": @(instructionOffset),
                            @"address": @(addr)
                        };
                    }
                }
            }
        }
    }

    return nil;
}

- (void)showFunctionWithPseudoCode:(DetectedFunction *)function {
    NSMutableString *details = [NSMutableString string];

    // Function Header
    [details appendFormat:@"FUNCTION: %@\n", function.displayName];
    [details appendFormat:@"Address: 0x%llx - 0x%llx\n", function.startAddress, function.endAddress];
    [details appendFormat:@"Size: %lu bytes (%lu instructions)\n",
            (unsigned long)function.size,
            (unsigned long)function.instructionCount];

    // Cross-References
    NSArray<XREF *> *incomingXREFs = [self.xrefManager getIncomingXREFs:function.startAddress];
    NSArray<XREF *> *outgoingXREFs = [self.xrefManager getOutgoingXREFs:function.startAddress];

    [details appendFormat:@"XREFs: %lu incoming, %lu outgoing\n\n",
            (unsigned long)incomingXREFs.count,
            (unsigned long)outgoingXREFs.count];

    // Show incoming references
    if (incomingXREFs.count > 0) {
        [details appendString:@"INCOMING REFERENCES:\n"];
        for (XREF *xref in incomingXREFs) {
            [details appendFormat:@"  %@ 0x%llx ‚Üí 0x%llx\n",
                    [xref typeSymbol], xref.fromAddress, xref.toAddress];
        }
        [details appendString:@"\n"];
    }

    // Show outgoing references
    if (outgoingXREFs.count > 0 && outgoingXREFs.count <= 10) {
        [details appendString:@"OUTGOING REFERENCES:\n"];
        for (XREF *xref in outgoingXREFs) {
            [details appendFormat:@"  %@ 0x%llx ‚Üí 0x%llx\n",
                    [xref typeSymbol], xref.fromAddress, xref.toAddress];
        }
        [details appendString:@"\n"];
    }

    // Separator
    [details appendString:@"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"];
    [details appendString:@"PSEUDO-CODE:\n"];
    [details appendString:@"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n"];

    // Generate Pseudo-Code with Syntax Highlighting
    NSMutableAttributedString *attributedDetails = [[NSMutableAttributedString alloc] initWithString:details];

    if (self.pseudoCodeGen && self.binaryData) {
        NSString *pseudoCode = [self.pseudoCodeGen generatePseudoCodeForFunction:function
                                                                      binaryData:self.binaryData
                                                                     baseAddress:0x100000000];

        // Apply syntax highlighting to pseudo-code
        NSAttributedString *highlightedPseudo = [self.syntaxHighlighter highlightPseudoCode:pseudoCode];
        [attributedDetails appendAttributedString:highlightedPseudo];
    } else {
        [details appendString:@"// Pseudo-code generator not available\n"];
        [attributedDetails appendAttributedString:[[NSAttributedString alloc] initWithString:@"// Pseudo-code generator not available\n"]];
    }

    [details appendString:@"\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"];
    [details appendString:@"DISASSEMBLY:\n"];
    [details appendString:@"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n"];
    [attributedDetails appendAttributedString:[[NSAttributedString alloc] initWithString:@"\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nDISASSEMBLY:\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n"]];

    // Disassembly with Syntax Highlighting
    NSMutableString *assemblyText = [NSMutableString string];
    if (self.binaryData && function.startAddress >= 0x100000000) {
        uint64_t offset = function.startAddress - 0x100000000;
        const uint8_t *bytes = (const uint8_t *)[self.binaryData bytes];

        for (uint64_t addr = function.startAddress; addr < function.endAddress; addr += 4) {
            if (offset + (addr - function.startAddress) + 4 <= self.binaryData.length) {
                const uint8_t *instrBytes = bytes + offset + (addr - function.startAddress);
                ARM64Instruction *inst = [self.disasm.decoder decodeInstructionAtAddress:addr
                                                                                    data:instrBytes
                                                                                  length:4];
                if (inst) {
                    [assemblyText appendFormat:@"%@\n", [inst hopperStyleDescription]];
                }
            }
        }

        // Apply syntax highlighting to assembly
        NSAttributedString *highlightedAsm = [self.syntaxHighlighter highlightAssembly:assemblyText];
        [attributedDetails appendAttributedString:highlightedAsm];
    }

    // Show in new view controller with syntax highlighting
    UIViewController *detailVC = [[UIViewController alloc] init];
    detailVC.title = function.displayName;

    UITextView *textView = [[UITextView alloc] initWithFrame:detailVC.view.bounds];
    textView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
    textView.font = [UIFont fontWithName:@"Menlo" size:11];
    textView.backgroundColor = self.syntaxHighlighter.backgroundColor;
    textView.attributedText = attributedDetails;
    textView.editable = NO;
    textView.backgroundColor = [UIColor colorWithRed:0.1 green:0.1 blue:0.12 alpha:1.0];
    textView.textColor = [UIColor colorWithRed:0.8 green:0.9 blue:1.0 alpha:1.0];
    textView.alwaysBounceVertical = YES;
    textView.showsVerticalScrollIndicator = YES;

    [detailVC.view addSubview:textView];

    [self.navigationController pushViewController:detailVC animated:YES];
}

- (void)showClassDetailsAtIndex:(NSInteger)index {
    if (!self.objcAnalyzer || index >= self.objcAnalyzer.classes.count) {
        return;
    }

    ObjCClass *cls = self.objcAnalyzer.classes[index];

    NSMutableString *details = [NSMutableString string];
    [details appendString:@"CLASS DETAILS\n"];
    [details appendString:@"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n"];
    [details appendFormat:@"@interface %@", cls.className ?: @"(unknown)"];

    if (cls.superClassName) {
        [details appendFormat:@" : %@", cls.superClassName];
    }

    [details appendString:@"\n\n"];

    // Instance Variables
    if (cls.ivars && cls.ivars.count > 0) {
        [details appendString:@"Instance Variables:\n"];
        for (ObjCIvar *ivar in cls.ivars) {
            [details appendFormat:@"  %@ %@;\n", ivar.type ?: @"id", ivar.name ?: @"(unknown)"];
        }
        [details appendString:@"\n"];
    }

    // Properties
    if (cls.properties && cls.properties.count > 0) {
        [details appendString:@"Properties:\n"];
        for (ObjCProperty *prop in cls.properties) {
            [details appendFormat:@"  @property %@ %@;\n", prop.attributes ?: @"", prop.name ?: @"(unknown)"];
        }
        [details appendString:@"\n"];
    }

    // Instance Methods
    if (cls.instanceMethods && cls.instanceMethods.count > 0) {
        [details appendFormat:@"Instance Methods: (%lu)\n", (unsigned long)cls.instanceMethods.count];
        for (ObjCMethod *method in cls.instanceMethods) {
            [details appendFormat:@"  - %@  @ 0x%llx\n",
                    method.name ?: @"(unknown)", method.implementation];
        }
        [details appendString:@"\n"];
    }

    // Class Methods
    if (cls.classMethods && cls.classMethods.count > 0) {
        [details appendFormat:@"Class Methods: (%lu)\n", (unsigned long)cls.classMethods.count];
        for (ObjCMethod *method in cls.classMethods) {
            [details appendFormat:@"  + %@  @ 0x%llx\n",
                    method.name ?: @"(unknown)", method.implementation];
        }
        [details appendString:@"\n"];
    }

    [details appendString:@"@end\n"];

    // Show in text view
    self.mainTextView.text = details;
    self.mainTextView.hidden = NO;
    self.tableView.hidden = YES;
}

- (void)showFunctionCodeAtIndex:(NSInteger)index {
    if (!self.functionAnalyzer || index >= self.functionAnalyzer.functions.count) {
        return;
    }

    DetectedFunction *func = self.functionAnalyzer.functions[index];

    NSMutableString *code = [NSMutableString string];

    // Function Header
    [code appendString:@"FUNCTION DISASSEMBLY\n"];
    [code appendString:@"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n"];
    [code appendFormat:@"Function: %@\n", func.displayName ?: [NSString stringWithFormat:@"sub_%llx", func.startAddress]];
    [code appendFormat:@"Address: 0x%llx - 0x%llx\n", func.startAddress, func.endAddress];
    [code appendFormat:@"Size: %lu bytes | %lu instructions\n",
            (unsigned long)func.size, (unsigned long)func.instructionCount];

    if (func.callsTo.count > 0) {
        [code appendFormat:@"Calls: %lu function(s)\n", (unsigned long)func.callsTo.count];
    }

    if (func.calledFrom.count > 0) {
        [code appendFormat:@"Called from: %lu location(s)\n", (unsigned long)func.calledFrom.count];
    }

    [code appendString:@"\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n"];

    // Generate Pseudo-Code
    if (self.pseudoCodeGen && self.binaryData) {
        [code appendString:@"PSEUDO-CODE:\n\n"];
        NSString *pseudoCode = [self.pseudoCodeGen generatePseudoCodeForFunction:func
                                                                      binaryData:self.binaryData
                                                                     baseAddress:0x100000000];
        [code appendString:pseudoCode];
        [code appendString:@"\n\n"];
    }

    // Assembly Code
    [code appendString:@"ASSEMBLY:\n\n"];

    if (self.binaryData && func.startAddress >= 0x100000000) {
        uint64_t offset = func.startAddress - 0x100000000;
        const uint8_t *bytes = (const uint8_t *)[self.binaryData bytes];

        ARM64InstructionDecoder *decoder = [[ARM64InstructionDecoder alloc] init];

        for (uint64_t addr = func.startAddress; addr < func.endAddress && addr < func.startAddress + 0x400; addr += 4) {
            if (offset + (addr - func.startAddress) + 4 <= self.binaryData.length) {
                const uint8_t *instrBytes = bytes + offset + (addr - func.startAddress);
                ARM64Instruction *inst = [decoder decodeInstructionAtAddress:addr
                                                                        data:instrBytes
                                                                      length:4];

                if (inst) {
                    [code appendFormat:@"%@\n", [inst hopperStyleDescription]];
                }
            }
        }
    }

    // Cross-References
    if (func.calledFrom && func.calledFrom.count > 0) {
        [code appendString:@"\nCALLED FROM:\n"];
        for (NSNumber *addr in func.calledFrom) {
            [code appendFormat:@"  0x%llx\n", [addr unsignedLongLongValue]];
        }
    }

    if (func.callsTo && func.callsTo.count > 0) {
        [code appendString:@"\nCALLS TO:\n"];
        for (NSNumber *addr in func.callsTo) {
            [code appendFormat:@"  0x%llx\n", [addr unsignedLongLongValue]];
        }
    }

    // Show in NEW view controller with navigation
    UIViewController *detailVC = [[UIViewController alloc] init];
    detailVC.title = func.displayName ?: [NSString stringWithFormat:@"sub_%llx", func.startAddress];

    UITextView *textView = [[UITextView alloc] initWithFrame:detailVC.view.bounds];
    textView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
    textView.font = [UIFont fontWithName:@"Menlo" size:11];
    textView.text = code;
    textView.editable = NO;
    textView.backgroundColor = [UIColor colorWithRed:0.1 green:0.1 blue:0.12 alpha:1.0];
    textView.textColor = [UIColor colorWithRed:0.8 green:0.9 blue:1.0 alpha:1.0];
    textView.alwaysBounceVertical = YES;
    textView.showsVerticalScrollIndicator = YES;

    [detailVC.view addSubview:textView];

    // Push to navigation controller so user can go back
    [self.navigationController pushViewController:detailVC animated:YES];
}

- (void)showXREFDetailsAtIndex:(NSInteger)index {
    // Show cross-reference details
    // Implementation similar to showFunctionCodeAtIndex
}

#pragma mark - XREF Building

- (void)buildXREFsFromFunctions {
    // Build cross-references from all detected functions
    for (DetectedFunction *function in self.functionAnalyzer.functions) {
        if (!self.binaryData || function.startAddress < 0x100000000) continue;

        uint64_t offset = function.startAddress - 0x100000000;
        const uint8_t *bytes = (const uint8_t *)[self.binaryData bytes];

        // Analyze each instruction in the function
        for (uint64_t addr = function.startAddress; addr < function.endAddress; addr += 4) {
            if (offset + (addr - function.startAddress) + 4 > self.binaryData.length) break;

            const uint8_t *instrBytes = bytes + offset + (addr - function.startAddress);
            ARM64Instruction *inst = [self.disasm.decoder decodeInstructionAtAddress:addr
                                                                                data:instrBytes
                                                                              length:4];

            if (!inst) continue;

            NSString *mnemonic = inst.mnemonic;
            uint64_t instrOffset = addr - function.startAddress;

            // Extract target address from operands if present
            uint64_t targetAddr = [self extractTargetAddressFromOperands:inst.operands];

            // Track different types of references
            if ([mnemonic isEqualToString:@"BL"] || [mnemonic isEqualToString:@"BLR"]) {
                // Function call
                if (targetAddr != 0) {
                    [self.xrefManager addXREFFrom:addr
                                               to:targetAddr
                                             type:XREFTypeCall
                                      instruction:[inst hopperStyleDescription]
                                           offset:instrOffset];
                }
            }
            else if ([mnemonic isEqualToString:@"B"] || [mnemonic isEqualToString:@"BR"]) {
                // Jump/Branch
                if (targetAddr != 0) {
                    [self.xrefManager addXREFFrom:addr
                                               to:targetAddr
                                             type:XREFTypeJump
                                      instruction:[inst hopperStyleDescription]
                                           offset:instrOffset];
                }
            }
            else if ([mnemonic isEqualToString:@"ADRP"] || [mnemonic isEqualToString:@"ADR"]) {
                // Potential string or data reference
                if (targetAddr != 0) {
                    // Check if it's a string
                    NSString *string = [self resolveStringAtAddress:targetAddr];
                    XREFType type = string ? XREFTypeStringRef : XREFTypeCodeRef;

                    [self.xrefManager addXREFFrom:addr
                                               to:targetAddr
                                             type:type
                                      instruction:[inst hopperStyleDescription]
                                           offset:instrOffset];
                }
            }
            else if ([mnemonic isEqualToString:@"LDR"] || [mnemonic isEqualToString:@"LDRB"] ||
                     [mnemonic isEqualToString:@"LDRH"] || [mnemonic isEqualToString:@"LDRSW"]) {
                // Data read
                if (targetAddr != 0) {
                    [self.xrefManager addXREFFrom:addr
                                               to:targetAddr
                                             type:XREFTypeDataRead
                                      instruction:[inst hopperStyleDescription]
                                           offset:instrOffset];
                }
            }
            else if ([mnemonic isEqualToString:@"STR"] || [mnemonic isEqualToString:@"STRB"] ||
                     [mnemonic isEqualToString:@"STRH"]) {
                // Data write
                if (targetAddr != 0) {
                    [self.xrefManager addXREFFrom:addr
                                               to:targetAddr
                                             type:XREFTypeDataWrite
                                      instruction:[inst hopperStyleDescription]
                                           offset:instrOffset];
                }
            }
        }
    }
}

- (uint64_t)extractTargetAddressFromOperands:(NSString *)operands {
    // Extract target address from operands string
    // Example: "sub_100028420" or "#0x100028420" or "0x100028420"

    if (!operands || operands.length == 0) return 0;

    // Look for hex address pattern (0x...)
    NSRange range = [operands rangeOfString:@"0x" options:NSBackwardsSearch];
    if (range.location != NSNotFound) {
        NSString *addrStr = [operands substringFromIndex:range.location];

        // Extract only hex digits after 0x
        NSScanner *scanner = [NSScanner scannerWithString:addrStr];
        unsigned long long addr = 0;
        if ([scanner scanHexLongLong:&addr]) {
            return (uint64_t)addr;
        }
    }

    // Look for "sub_..." pattern
    range = [operands rangeOfString:@"sub_"];
    if (range.location != NSNotFound) {
        NSString *addrStr = [operands substringFromIndex:range.location + 4]; // Skip "sub_"
        NSScanner *scanner = [NSScanner scannerWithString:addrStr];
        unsigned long long addr = 0;
        if ([scanner scanHexLongLong:&addr]) {
            return (uint64_t)addr;
        }
    }

    return 0;
}

- (NSString *)resolveStringAtAddress:(uint64_t)address {
    // Try to resolve string at given address
    if (!self.binaryData || address < 0x100000000) return nil;

    uint64_t offset = address - 0x100000000;
    if (offset >= self.binaryData.length) return nil;

    const char *bytes = (const char *)[self.binaryData bytes];
    const char *strPtr = bytes + offset;

    // Check if it looks like a valid string
    if (offset + 4 > self.binaryData.length) return nil;

    // Read up to 256 bytes or until null terminator
    NSMutableString *str = [NSMutableString string];
    for (int i = 0; i < 256 && (offset + i) < self.binaryData.length; i++) {
        char c = strPtr[i];
        if (c == 0) break;
        if (c < 32 || c > 126) return nil; // Not printable ASCII
        [str appendFormat:@"%c", c];
    }

    return str.length > 0 ? str : nil;
}

#pragma mark - Helper Methods for Syntax Highlighting

// Set text with automatic syntax highlighting
- (void)setHighlightedText:(NSString *)text {
    [self setHighlightedText:text isCode:YES];
}

- (void)setHighlightedText:(NSString *)text isCode:(BOOL)isCode {
    if (!text || text.length == 0) {
        [self setHighlightedText:@"" isCode:NO];
        return;
    }

    if (!isCode || !self.syntaxHighlighter) {
        // ÿπÿ±ÿ∂ ÿπÿßÿØŸä ÿ®ÿØŸàŸÜ ÿ£ŸÑŸàÿßŸÜ
        self.mainTextView.text = text;
        return;
    }

    // ÿ™ÿ∑ÿ®ŸäŸÇ syntax highlighting
    NSMutableAttributedString *attributed = [[NSMutableAttributedString alloc] init];

    // Default attributes
    NSDictionary *defaultAttrs = @{
        NSForegroundColorAttributeName: self.syntaxHighlighter.textColor,
        NSFontAttributeName: self.syntaxHighlighter.font
    };

    // Check if text contains assembly or pseudo-code
    BOOL hasAssembly = [text containsString:@"0x"] && ([text containsString:@":"] || [text containsString:@"  "]);

    if (hasAssembly) {
        // Assembly code - highlight each line
        NSArray *lines = [text componentsSeparatedByString:@"\n"];
        for (NSString *line in lines) {
            NSAttributedString *highlighted = [self.syntaxHighlighter highlightAssemblyLine:line];
            if (highlighted) {
                [attributed appendAttributedString:highlighted];
            } else {
                NSAttributedString *plain = [[NSAttributedString alloc] initWithString:line attributes:defaultAttrs];
                [attributed appendAttributedString:plain];
            }

            // Add newline
            NSAttributedString *newline = [[NSAttributedString alloc] initWithString:@"\n" attributes:defaultAttrs];
            [attributed appendAttributedString:newline];
        }
    } else {
        // Pseudo-code or generic code
        NSAttributedString *highlighted = [self.syntaxHighlighter highlightPseudoCode:text];
        [attributed appendAttributedString:highlighted];
    }

    // Set attributed text
    self.mainTextView.attributedText = attributed;
}

#pragma mark - Progressive Disassembly for Large Files

- (void)updateStatusBar:(NSString *)fileName size:(NSUInteger)fileSize progress:(NSString *)progressText {
    dispatch_async(dispatch_get_main_queue(), ^{
        if (fileName) {
            self.statusFileLabel.text = fileName;
        }

        if (fileSize > 0) {
            if (fileSize < 1024) {
                self.statusSizeLabel.text = [NSString stringWithFormat:@"%lu bytes", (unsigned long)fileSize];
            } else if (fileSize < 1024 * 1024) {
                self.statusSizeLabel.text = [NSString stringWithFormat:@"%.1f KB", fileSize / 1024.0];
            } else {
                self.statusSizeLabel.text = [NSString stringWithFormat:@"%.2f MB", fileSize / (1024.0 * 1024.0)];
            }
        }

        if (progressText) {
            self.statusProgressLabel.text = progressText;
        }
    });
}

- (void)showProgressWithMessage:(NSString *)message {
    dispatch_async(dispatch_get_main_queue(), ^{
        self.progressBar.hidden = NO;
        self.progressLabel.hidden = NO;

        [UIView animateWithDuration:0.3 animations:^{
            self.progressBar.alpha = 1.0;
            self.progressLabel.alpha = 1.0;
        }];

        self.progressLabel.text = message;
        self.progressBar.progress = 0.0;
    });
}

- (void)hideProgress {
    dispatch_async(dispatch_get_main_queue(), ^{
        [UIView animateWithDuration:0.3 animations:^{
            self.progressBar.alpha = 0.0;
            self.progressLabel.alpha = 0.0;
        } completion:^(BOOL finished) {
            self.progressBar.hidden = YES;
            self.progressLabel.hidden = YES;
        }];
    });
}

- (void)updateProgress:(float)progress message:(NSString *)message {
    dispatch_async(dispatch_get_main_queue(), ^{
        self.progressBar.progress = progress;
        if (message) {
            self.progressLabel.text = message;
        }
    });
}

@end

#pragma mark - CFGGenerator Implementation

@implementation CFGGenerator

- (NSDictionary *)generateCFGForFunction:(uint64_t)address {
    // TODO: Full CFG generation
    return @{};
}

- (NSArray *)findBasicBlocks:(uint64_t)address {
    // TODO: Basic block identification
    return @[];
}

@end
